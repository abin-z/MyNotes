*MySQL进阶**

[**MySQL 5.1中文文档**](https://www.mysqlzh.com/)

[MySQL官方文档](https://dev.mysql.com/doc/)

[#数据库](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI4NjY4MTU5Nw==&action=getalbum&album_id=1500546306904260609&scene=173&from_msgid=2247485306&from_itemidx=1&count=3&nolastread=1#wechat_redirect)

[深入理解 MySQL ——锁、事务与并发控制](https://mp.weixin.qq.com/s?__biz=MzI4NjY4MTU5Nw==&mid=2247485306&idx=1&sn=eca2fd59c65ef4579de248e4fa36baf2&chksm=ebd877e8dcaffefec64ea929a3bd360cec403d83b54a4aeaf9dfe535119cf85cfcaffe31e5ed&scene=178&cur_album_id=1500546306904260609#rd)



# 一. MySQL的执行原理

## 1. MySQL架构图

当我们对网站或者App做出操作去访问数据时，其实归根到底是一条SQL语句的执行，那么一条SQL语句到底是怎么执行的呢？

![preview](https://gitee.com/abin_z/pic_bed/raw/master/v2-8a773bde2b5ec56bead25ad57dc76d1f_r.jpg)

MySQL官方提供的MySQL架构图，我们可以清楚的看到一个连接是要经过很多个步骤最后才获得结果的。

博客园中找到一张较为清楚的图片:

![v2-df7af3acb9b9e050348bc6f00163a7a5_r](https://gitee.com/abin_z/pic_bed/raw/master/v2-df7af3acb9b9e050348bc6f00163a7a5_r.jpg)



## 2. MySQL架构解析

**MySQL主要分为==Server层== 和 ==存储引擎层==**

- **server层:**

​		主要包括**连接器、查询缓存（MySQL8.0移除）、分析器、优化器、执行器**等，

​		所有的跨存储引擎的功能都在这一层实现，比**如存储过程、触发器、视图、函数**等，还有一个**通用的日志模块binglog**

- **存储引擎层:**

​		**主要负责数据的存储和读取**，采用可以替换的插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，

​		存储引擎层和server层是可分离的，插件式的，默认的是InnoDB

​		其中InnnoDB有属于自己的日志模块（下文会介绍到）。**「现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始被当做默认的存储引擎了。」**



更加简显易懂的体系结构图: 

![v2-760f1324c080d37a8590b45316827b04_r](https://gitee.com/abin_z/pic_bed/raw/master/v2-760f1324c080d37a8590b45316827b04_r.jpg)

## 3.**组件的详细介绍**

#### 1.连接器 (验证身份+权限判定)

**主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作**，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。

> 连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。



#### 2.查询缓存 (8.0后被移除)

**连接建立后，执行查询语句的时候，会先查询缓存**，MySQL 会先校验这个 sql 语句是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。

**MySQL 8.0 版本后删除了缓存的功能**，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。

> 为什么8.0过后要移除缓存?
>
> 因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。



#### 3.分析器（词法分析+语法分析）

MySQL 没有命中缓存，那么就会进入分析器，**分析器主要是用来分析 SQL 语句是来干嘛的**，分析器也会分为几步：

分析器，词法分析，语法分析，语义分析，在这里会返回You have an error in your SQL的错误消息，这里会检查表信息，会抛出表字段不存在等错误消息

- 第一步，**词法分析**

  一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。

- 第二步，**语法分析**

  主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。

完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。



#### 4.优化器（选取MySQL认为最优的方案执行）

**优化器的作用就是它认为的`'最优的执行方案'`去执行（有时候可能也不是最优）**，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。

可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。



#### 5.执行器 (选择对应的存储引擎开始执行) 

当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，**就会去调用引擎的接口，返回接口执行的结果。**



> 来张图了解整个过程

![v2-38ce979bcec53ad082d2e15cb330b0c3_r](https://gitee.com/abin_z/pic_bed/raw/master/v2-38ce979bcec53ad082d2e15cb330b0c3_r.jpg)

### 4.语句分析

究竟一条sql语句是怎么执行的呢？其实sql语句大致上可以分为两种，一种是查询语句，一种是更新语句（增加、更新、删除）。

#### 4.1 查询语句

- 查询语句:

```sql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```

分析一下这条语句的具体执行流程：

1. **先检查该语句是否有权限**，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。

2. **通过分析器进行词法分析**，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。

3. **接下来就是优化器进行确定执行方案**，上面的 sql 语句，可以有两种执行方案：

   > 方案a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18

   > 方案b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。

​		那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（**优化器认为，有时候不一定最好**）。那么确认了执行计划后就准备开始执行了。

4. **进行权限校验**，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。



#### 4.2 日志

由于更新语句设计到日志操作，所以先介绍一下日志log。

- ### **binlog 归档日志**

`binlog`（归档日志）是MySQL的Server层有的。 逻辑日志

**主要记录用户对数据库操作的SQL语句**

> binlog 属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠 binlog 是没有 crash-safe 能力的。
> binlog 有两种模式，statement 格式的话是记 sql 语句，row 格式会记录行的内容，记两条，更新前和更新后都有。
> sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

正是由于binlog有归档的作用，**所以binlog主要用作主从同步和数据库基于时间点的还原**。在mysql数据库主从复制中有用到binlog

`tips：`crash-safe 指MySQL服务器宕机重启后，能够保证：

 		所有已经提交的事务的数据仍然存在。

​		 所有没有提交的事务的数据自动回滚。



- ### **undo log 归档日志**

`undo log`（回滚日志）==InnoDB 引擎特有的日志==

**undo log顾名思义，主要就是提供了回滚的作用，但其还有另一个主要作用，就是多个行版本控制(MVCC)，保证事务的原子性**。==在数据修改的流程中，**会记录一条与当前操作相反的逻辑日志**到undo log中==(可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录) 如果因为某些原因导致事务异常失败了，可以借助该undo log进行回滚，保证事务的完整性，**所以undo log也必不可少。**



- ### **redo log (重做日志)**

`redo log` （重做日志）**是 ==InnoDB 引擎特有的日志==。物理日志**

**记录的是数据库中每个页的修改，可以用来恢复提交后的物理数据页**（恢复数据页，且**只能恢复到最后一次提交的位置**，因为修改会覆盖之前的）。

> 在 MySQL 中，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就采用了日志（redo log）来提升更新效率。
> 而日志和磁盘配合的整个过程，其实就是 MySQL 里的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是**先写日志，再写磁盘**。
> 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（redolog buffer）里面，并更新内存（buffer pool），这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候（如系统空闲时），将这个操作记录更新到磁盘里面（刷脏页）。

**redo log 是 InnoDB 存储引擎层的日志，又称重做日志文件，==redo log 是顺序循环写的==**，相比于更新数据文件的随机写，日志的写入开销更小，能显著提升语句的执行性能，提高并发量。

> 在redo log满了到擦除旧记录腾出新空间这段期间，是不能再接收新的更新请求，所以有可能会导致MySQL卡顿。（所以针对并发量大的系统，适当设置redo log的文件大小非常重要）

redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么日志总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。



- **redo log 和 binlog 区别：**
  1. **redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。**
  2. **redo log 是物理日志，记录的是在某个数据页上做了什么修改，记录了数据；binlog 是逻辑日志，记录的是这个语句的原始逻辑。**
  3. **redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。追加写是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。**
  3. **redo log影响主库的数据，binlog影响从库的数据，所以redo log和binlog必须保持一致才能保证主从数据一致，这是前提。**



#### 4.3 更新语句

说完日志，我们再来看一下更新语句，我们看下面这条语句：

```text
UPDATE` ``test` ``SET` ``c` = `c` + 1 ``WHERE` ``id` = 1;
```

语句的意思是找到id为1的那条数据，将c这列的值+1。

这条语句的操作顺序是怎么样的呢？

**操作顺序**

1. 「**查找记录」**: 执行器先找引擎取id=1这一行。ID是主键，引擎直接用树搜索找到这一行。如果id=1这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回；
2. **「执行器」**拿到引擎返回的行数据，把c+1，得到新的一行数据，再调用引擎接口写入这行新数据；
3.  引擎将这行新数据更新到**「内存」**中，同时**「将这个更新之后的数据记录到redo log里面」**，此时redo log处于**「prepare」**状态；
4. 引擎告知执行器，我执行完成了，你随时可以调我的接口提交事务了；
5. 执行器生成这个操作的binlog，并把**「binlog」**写入磁盘。
6. 执行器调用引擎的提交事务接口, **「引擎把刚刚写入的redo log改成」**提交commit状态，更新完成。

思路图:

![v2-829f090ec9c882505262d0e0330cc03e_1440w](https://gitee.com/abin_z/pic_bed/raw/master/v2-829f090ec9c882505262d0e0330cc03e_1440w.jpg)



> 那么**为什么redo log要分两步写，中间再穿插写binlog呢？**

在上图中我们可以看到redolog分为两个阶段，那为什么要这样呢？如果不这样会发生什么问题？下面我们用反证法进行论述：

- **「先写redolog并提交，然后再写binlog」**，假设redolog写完后，机器宕机了，这个时候binlog没有写入，机器重新启动之后，由于redo log已经写完了，系统重启后会通过redo log将数据恢复回来，但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的数据与原库的值不同。造成了主从不一致
- **「先写 binlog，然后写 redo log」**，如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以没有记录到redolog。但是binlog里面已经记录了日志。所以，在之后用binlog来恢复的时候，恢复出来的临时库中的数据就与原库的值不同。





### 5.MySQL执行原理脑图

![v2-1b4b32eb5da73b6aefd81e541feaecbf_r](https://gitee.com/abin_z/pic_bed/raw/master/v2-1b4b32eb5da73b6aefd81e541feaecbf_r.jpg)





相关文档:

[全面了解MySQL的执行原理](https://zhuanlan.zhihu.com/p/352436463)





# 二.MySQL的 crash-safe 

MySQL作为当下最流行的开源关系型数据库，有一个很关键和基本的能力，就是必须能够保证数据不会丢。那么在这个能力背后，MySQL是如何设计才能保证不管在什么时间崩溃，恢复后都能保证数据不会丢呢？有哪些关键技术支撑了这个能力？

相关文档： [MySQL 的 crash-safe 原理解析](https://zhuanlan.zhihu.com/p/142491549)

## 1、前言

MySQL 保证数据不会丢的能力主要体现在两方面：

1. **能够恢复到任何时间点的状态；**    依赖**binlog**
2. **能够保证MySQL在任何时间段突然奔溃，重启后之前提交的记录都不会丢失；**       依赖**InnoDB的redo log和undo log**

对于第一点的能力,   将MySQL恢复到任何时间点的状态，相信很多人都知道，只要保留有足够的**binlog**，就能通过重跑binlog来实现。

对于第二点的能力，也就是本文标题所讲的**crash-safe**。即在 InnoDB 存储引擎中，事务提交过程中任何阶段，MySQL突然奔溃，重启后都能保证事务的完整性，已提交的数据不会丢失，未提交完整的数据会自动进行回滚。这个能力依赖的就是**redo log和unod log**两个日志。



因为crash-safe主要体现在事务执行过程中突然奔溃，重启后能保证事务完整性，所以在讲解具体原理之前，先了解下MySQL事务执行有哪些关键阶段，后面才能依据这几个阶段来进行解析。下面以一条更新语句的执行流程为例，话不多说，直接上图：

![image-20220307235519366](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307235519366.png)

从上图可以清晰地看出一条更新语句在MySQL中是怎么执行的，简单进行总结一下：

1. > 从内存中找出这条数据记录，对其进行更新；

2. > 将对数据页的更改记录到redo log中；

3. > 将逻辑操作记录到binlog中；

4. > 对于内存中的数据和日志，都是由后台线程，当触发到落盘规则后再异步进行刷盘；



## 2、WAL机制

**问题：为什么不直接更改磁盘中的数据，而要在内存中更改，然后还需要写日志，最后再落盘这么复杂？**

这个问题相信很多同学都能猜出来，MySQL更改数据的时候，之所以不直接写磁盘文件中的数据**，最主要就是性能问题。因为直接写磁盘文件是随机写，开销大性能低，没办法满足MySQL的性能要求**。所以才会设计成先在内存中对数据进行更改，再异步落盘。但是内存总是不可靠，万一断电重启，还没来得及落盘的内存数据就会丢失，所以还需要加上写日志这个步骤，万一断电重启，还能通过日志中的记录进行恢复。

**写日志虽然也是写磁盘，但是它是顺序写，相比随机写开销更小**，能提升语句执行的性能（针对顺序写为什么比随机写更快，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多）。

这个技术就是大多数存储系统基本都会用的**WAL(Write Ahead Log)技术，也称为日志先行的技术，指的是对数据文件进行修改前，必须将修改先记录日志。保证了数据一致性和持久性，并且提升语句执行性能。**



## 3、核心日志模块

**问题：更新SQL语句执行流程中，总共需要写3个日志，这3个是不是都需要，能不能进行简化？**

更新SQL执行过程中，总共涉及**MySQL日志模块其中的三个核心日志，分别是redo log（重做日志）、undo log（回滚日志）、binlog（归档日志）。**这里提前预告，crash-safe的能力主要依赖的就是这三大日志。



### **1、重做日志 redo log**

**redo log也称为事务日志，由InnoDB存储引擎层产生。记录的是数据库中每个页的修改，而不是某一行或某几行修改成怎样，可以用来恢复提交后的物理数据页**（恢复数据页，且只能恢复到最后一次提交的位置，因为修改会覆盖之前的）。

​		前面提到的WAL技术，redo log就是WAL的典型应用，==**MySQL在有事务提交对数据进行更改时，只会在内存中修改对应的数据页和记录redo log日志，完成后即表示事务提交成功，至于磁盘数据文件的更新则由后台线程异步处理**==。由于redo log的加入，保证了MySQL数据一致性和持久性（即使数据刷盘之前MySQL奔溃了，重启后仍然能通过redo log里的更改记录进行重放，重新刷盘），此外还能提升语句的执行性能（**写redo log是顺序写**，相比于更新数据文件的随机写，日志的写入开销更小，能显著提升语句的执行性能，提高并发量），由此可见redo log是必不可少的。

​		**==redo log是固定大小的，所以只能循环写==，从头开始写，写到末尾就又回到开头，相当于一个环形**。当日志写满了，就需要对旧的记录进行擦除，但在擦除之前，需要确保这些要被擦除记录对应在内存中的数据页都已经刷到磁盘中了。**在redo log满了到擦除旧记录腾出新空间这段期间，是不能再接收新的更新请求，所以有可能会导致MySQL卡顿。**（==所以针对并发量大的系统，适当设置redo log的文件大小非常重要！！！==）



### **2、回滚日志 undo log**

undo log顾名思义，**主要就是提供了回滚的作用**，但其还有另一个主要作用，就是**多个行版本控制(MVCC)，保证事务的原子性**。在数据修改的流程中，==**会记录一条与当前操作相反的逻辑日志到undo log中**==（可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录），如果因为某些原因导致事务异常失败了，可以借助该undo log进行回滚，保证事务的完整性，所以undo log也必不可少。

### **3、归档日志 binlog**

**binlog在MySQL的server层产生，不属于任何引擎，主要记录用户对数据库操作的SQL语句（除了查询语句）**。之所以将binlog称为归档日志，是因为binlog不会像redo log一样擦掉之前的记录循环写，而是一直记录（超过有效期才会被清理），如果超过单日志的最大值（默认1G，可以通过变量 max_binlog_size 设置），则会新起一个文件继续记录。但由于日志可能是基于事务来记录的(如InnoDB表类型)，而事务是绝对不可能也不应该跨文件记录的，如果正好binlog日志文件达到了最大值但事务还没有提交则不会切换新的文件记录，而是继续增大日志，所以 **max_binlog_size 指定的值和实际的binlog日志大小不一定相等**。

正是由于binlog有归档的作用，所以binlog主要用作主从同步和数据库基于时间点的还原。

那么回到刚才的问题，binlog可以简化掉吗？这里需要分场景来看：

1. **如果是主从模式下，binlog是必须的，因为从库的数据同步依赖的就是binlog；**
2. 如果是单机模式，并且不考虑数据库基于时间点的还原，binlog就不是必须，因为有redo log就可以保证crash-safe能力了；但如果万一需要回滚到某个时间点的状态，这时候就无能为力，所以建议binlog还是一直开启；

根据上面对三个日志的详解，我们可以对这个问题进行解答：在主从模式下，三个日志都是必须的；在单机模式下，binlog可以视情况而定，保险起见最好开启。



# 三. 索引优化

> 对索引的优化是数据库性能优化方面最重要的一项，也是性能提升最显著的。

相关博客:   [MySQL性能优化](https://blog.hufeifei.cn/2018/04/DB/mysql/01-b-tree-hash-index/)



## 1.索引的本质

索引的本质: 

- **索引是帮助MySQL数据库高效获取数据的数据结构**
- **索引存储在文件里**

**如果把数据库比作一本新华字典，那索引就是字典前面的目录了**。如果不使用目录，想从字典中直接找某个字的解释，难度可想而知，但是有了目录，我们可以先从目录中找到这个字对应的页码，然后再翻到相应的页码，就能找到这个字的完整解释了。索引的工作原理和字典目录基本一致。

- ### B+tree索引是帮助MySQL高效获取数据的**==排好序的数据结构==**



我们知道，数据库查询是数据库最主要的功能之一，我们都希望查询数据的速度尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找，当然这种时间复杂度为O(n)的算法在数据量很大时显然是糟糕的，于是有了**二分查找、二叉树查找**等。

但是二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树，但是数据本身的组织结构不可能完全满足各种数据结构。所以，**==在数据之外，数据库系统还维护着满足特定查找算法的数据结构==，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引**。



## 2.索引分类

1 按索引逻辑存储结构划分可以分为：

- **B树索引**（按照物理存储结构又可以分为：聚簇索引和非聚簇索引）
- **Hash索引**    只有Memory引擎支持，场景简单
- 空间(Spatial)索引
- **全文(Fulltext)索引**

2 按索引是建立在单独的列，还是多列上。可以分为：

- **单列索引**
- **复合索引**(或者叫多列索引、组合索引)。

3 按索引的约束条件可以划分为：

- 主键(primary)索引
- 唯一(unique)索引



| 索引 / 存储引擎 | MyISAM   | InnoDB   | Memory   |
| :-------------- | :------- | :------- | :------- |
| B-Tree索引      | 支持     | 支持     | 支持     |
| HASH索引        | `不支持` | `不支持` | 支持     |
| R-Tree索引      | 支持     | 支持     | `不支持` |
| Full-text索引   | 支持     | 支持     | `不支持` |

最常用的索引也就是B-tree索引和Hash索引，且只有`Memory`，`NDB`两种引擎支持Hash索引。

Hash索引适于key-value查询，通过Hash索引比B-tree索引查询更加迅速。但Hash索引不支持范围查找例如<>, <=, >=等。



## 3.hash索引

### 3.1 hash索引原理

**hash索引基于==哈希表==实现**，**==只有精确匹配索引所有列的查询才有效==**。**Memory引擎**默认使用的是此种索引。

> 存储引擎对所有的索隐列计算出一个哈希码，将哈希码存储在索引中，同时哈希表中保存每个数据行的指针。这样，对于此种索引查找速度是非常快的。出现哈希值碰撞的话，索引会以链表的形式存放多个记录指针到同一个哈希条目中。

使用 **hash 自然会有哈希冲突可能，MySQL 采取拉链法解决**。

Hash索引基于Hash表实现，只有查询条件精确匹配Hash索引中的列时，才能够使用到hash索引。对于Hash索引中的所有列，存储引擎会为每行计算一个hashcode，Hash索引中存储的就是hashcode。值存在数组，用一个hash函数把key转换成一个确定的内存位置，然后把value放在数组的该位置。

![image-20220309101650206](https://gitee.com/abin_z/pic_bed/raw/master/image-20220309101650206.png)

比如我们想查`ID_card_n4`对应username：

1. 将`ID_card_n4`通过hash函数算出 A
2. 按顺序遍历，找到User4

四个`ID_card_n`值并不一定递增，这样即使增加新的User，速度也快，只需在后追加。

当然缺点也很明显，不是有序，所以hash索引做区间查询速度很慢。比如要找身份证号在ID_card_X, ID_card_Y区间的所有用户，就须全表扫描。

> 要使InnoDB或MyISAM支持哈希索引，可以通过伪哈希索引来实现，叫自适应哈希索引。 可通过增加一个字段，存储hash值，将hash值建立索引，在插入和更新的时候，建立触发器，自动添加计算后的hash到表里。



### 3.2 hash索引缺陷

- 必须二次查找, 但是速度依然很快
- 不支持部分索引查找、范围查找
- **哈希码可能存在哈希冲突**，如果hash 算法设计不好，碰撞过多，性能也会变差
- 索引存放的是hash值,**所以仅支持  =  以及 IN**
- 无法通过操作索引来排序，因为存放的时候会经过hash计算，但是计算的hash值和存放的不一定相等，所以无法排序
- 不能避免全表扫描，只是由于在memory表里支持非唯一值hash索引，即不同的索引键，可能存在相同hash值
- 因为哈希表是一种根据关键字直接访问内存存储位置的数据结构 ，所以利用其原理的hash 索引，也就需要将所有数据文件添加到内存，这就很耗内存
- 如果所有的查询都是等值查询，那么hash确实快，但实际上范围查找数据更多
- 只能处理键值的全值匹配查询
- Hash函数决定着索引键的大小



##  4. **为什么使用B+Tree树**

由于索引无法装入内存，则必然依赖磁盘（或SSD）存储。而内存的读写速度是磁盘的成千上万倍（与具体实现有关），因此，核心问题是“**如何减少磁盘读写次数**”。
首先不考虑页表机制，假设每次读、写都直接穿透到磁盘，那么：

- 线性结构：读/写平均O(n)次
- 二叉搜索树（BST）：读/写平均O(log2(n))次；如果树不平衡，则最差读/写O(n)次
- 自平衡二叉搜索树（AVL）：在BST的基础上加入了自平衡算法，读/写最大O(log2(n))次
- 红黑树（RBT）：另一种自平衡的查找树，读/写最大O(log2(n))次

BST、AVL、RBT很好的将读写次数从O(n)优化到O(log2(n))；其中，AVL和RBT都比BST多了自平衡的功能，将读写次数降到最大O(log2(n))。

#### 4.1 索引的思路

首先看一一个示例: 一种可能的索引方式



![img](https://gitee.com/abin_z/pic_bed/raw/master/20190521001020863.png)

上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（**注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的**）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用**二叉查找**在O(logn2)O(log2n)的复杂度内获取到相应数据。

虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的, mysql真实最常用使用的数据结构是**B+tree**



但是为什么数据库使用的是B+tree, 而不是   Binary Search Tree(二叉搜索树)   以及   AVL Tree(平衡二叉搜索树 )   以及   Red/Black Tree(红黑树) ?

这些数据结构都有什么性能问题?

**[数据结构可视化](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)**

#### 4.2 二叉搜索树



![image-20220308170532018](https://gitee.com/abin_z/pic_bed/raw/master/image-20220308170532018.png)

二叉查找树可以任意地构造, 但是这棵二叉树的查询效率就低了, 因为已经退化成类似于链表了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称AVL树。

#### 4.3 平衡二叉查找树(AVL-Tree)

![image-20220308170831605](https://gitee.com/abin_z/pic_bed/raw/master/image-20220308170831605.png)

平衡二叉树确实解决了退化成链表的问题, 似乎是一种可行的方案, 可以按着这个思路去进行拓展, 其实在数据量比较大的时候,这颗平衡二叉树的高度是很高的, **树的高度越高表示要进行I/O读写的次数越多**, 因此树的高度需要再继续优化. 此时可以用平衡多路查找树(B-Tree)



#### 4.4 平衡多路查找树（B-Tree）

B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。

系统从磁盘读取数据到内存时是以**磁盘块（block）**为基本单位的，**位于同一个磁盘块中的数据会被一次性读取出来**，而不是需要什么取什么。

**InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB**，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：

```sql
mysql> show variables like 'innodb_page_size';
```

而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。

B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。

一棵m阶的B-Tree有如下特性： 

1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)
8. ![image-20220308181239349](https://gitee.com/abin_z/pic_bed/raw/master/image-20220308181239349.png)

B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：

![索引](https://gitee.com/abin_z/pic_bed/raw/master/20160202204827368)



每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

模拟查找关键字29的过程：

1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2。
3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2。
5. 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
6. 在磁盘块8中的关键字列表中找到关键字29。

分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。**==B-Tree相对于AVLTree缩减了节点个数(树的高度)，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率==**。



#### 5.B+Tree

B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。在讲B+树之前必须先了解上面的二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。

![image-20220308181602049](https://gitee.com/abin_z/pic_bed/raw/master/image-20220308181602049.png)

**B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。**

从以上的**B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值**。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，**所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上**，而**非叶子节点上只存储key值信息**，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。



**B+Tree相对于B-Tree有几点不同**：

- #### **==非叶子节点只存储键值信息。==**

- #### ==所有叶子节点之间都有一个链指针。(子节点的地址)==

- #### ==数据记录都存放在叶子节点中。==

将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 

![索引](https://gitee.com/abin_z/pic_bed/raw/master/20160202205105560)

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且**==所有叶子节点（即数据节点）之间是一种链式环结构==**。因此可以对B+Tree进行两种查找运算：**一种是对于主键的==范围查找和分页查找==，另一种是从根节点开始，进行==随机查找==。**

可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：

InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为1000）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。**mysql的InnoDB存储引擎在设计时是将根节点常驻内存的**，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。



- #### 数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。

上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。**辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键**。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据(回表操作)。





## 5.B+Tree索引

相关博客: [MYSQL-B+TREE索引原理](https://www.jianshu.com/p/486a514b0ded)

### 5.1 B+Tree概述

与B-Tree相比，B+Tree有以下不同点：

- 非叶子节点不存储data，只存储索引key；
- 只有叶子节点才存储data。
- 存在索引冗余, 将下一节点最小的索引值存在本节点中



Mysql中B+Tree：在经典B+Tree的基础上进行了优化，**增加了顺序访问指针**。在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了**带有顺序访问指针的B+Tree**。这样就**提高了区间访问性能**：如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率(**无需返回上层父节点重复遍历查找减少IO操作**)。

结构如下图：

![image-20211001213607305](https://gitee.com/abin_z/pic_bed/raw/master/image-20211001213607305.png)



- **聚簇索引： 索引 和 数据文件为同一个文件**

- **非聚簇索引： 索引 和 数据文件分开的索引**

**MyISAM & InnoDB 都使用B+Tree索引结构。但是底层索引存储不同，MyISAM 采用非聚簇索引，而InnoDB采用聚簇索引。** 



### 5.2 非聚簇索引

**MyISAM索引原理：采用非聚簇索引-MyISAM myi索引文件 和myd数据文件分离，索引文件仅保存数据记录的指针地址。**

**叶子节点data域存储指向数据记录的指针地址。(底层存储结构： frm -表定义、 myi -myisam索引、 myd-myisam数据)**

![image-20220309112928096](https://gitee.com/abin_z/pic_bed/raw/master/image-20220309112928096.png)

MyISAM索引按照B+Tree搜索，如果指定的Key存在，则取出其data域的值，然后以data域值-数据指针地址去读取相应数据记录。辅助索引和主索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。MyISAM索引树如下：

![3575048-41ca8d0764b4e34d](https://gitee.com/abin_z/pic_bed/raw/master/3575048-41ca8d0764b4e34d.png)

### 5.3 聚簇索引

**聚集索引表示: 索引 和 数据文件为同一个文件**   InnoDB存储引擎使用的就是聚集索引

**InnoDB优势：**高扩展性，充分发挥硬件性能**、** Crash Safe、 支持事务、 可以在线热备份

**InnoDB特性：**

1. 事务支持（ACID）2. 扩展性优良 3. 读写不冲突 4. 缓存加速

2. 功能组件: redo/undo &  异步IO &  MVCC & 行级别锁 & Page Cache（LRU）

 **采用聚簇索引- InnoDB数据&索引文件为一个idb文件，表数据文件本身就是主索引，相邻的索引临近存储。 叶节点data域保存了完整的数据记录(数据[除主键id外其他列data]+主索引[索引key:表主键id])。 叶子节点直接存储数据记录，以主键id为key,叶子节点中直接存储数据记录。(底层存储结构:** frm -表定义、 ibd: innoDB数据&索引文件) 

![image-20220309113545781](https://gitee.com/abin_z/pic_bed/raw/master/image-20220309113545781.png)

 InnoDB索引结构图如下: 

![3575048-e81ac68c4020945e](https://gitee.com/abin_z/pic_bed/raw/master/3575048-e81ac68c4020945e.png)

**非主键索引(辅助索引)的叶子节点存放的是主键索引的索引key值, 当通过辅助索引查找到数据(data)时, 还会去主键索引里面去回表查找**

![3575048-cb474d18492d03e2](https://gitee.com/abin_z/pic_bed/raw/master/3575048-cb474d18492d03e2.png)

所以在InnoDB存储引擎下, **建议每一张表都建立主键索引,** 如果没有建主键索引, mysql数据库也会自动给没有主键索引的表建立主键索引

并且在建立主键索引值时候**MySQL官方建议是使用整型的数据类型, 并开启主键自增功能!**   仔细想想B+Tree的构建



### 5.4 索引查找流程

1.**索引精确查找**: 确定定位条件, 找到根节点Page No, 根节点读到内存, 逐层向下查找, 读取叶子节点Page,通过 二分查找找到记录或未命中。

```sql
select * from user_info where id = 23
```

![img](https://gitee.com/abin_z/pic_bed/raw/master/3575048-d268ee7a5a712071.png)



2**.索引范围查找**：读取根节点至内存, 确定索引定位条件id=18, 找到满足条件第一个叶节点, 顺序扫描所有结果, 直到终止条件满足id >=22 

```sql
select * from user_info where id >= 18 and id < 22
```

![img](https://gitee.com/abin_z/pic_bed/raw/master/3575048-8fef94a44ff7f1b0.png)



3. **全表扫描**：直接读取叶节点头结点， 顺序扫描， 返回符合条件记录， 到最终节点结束

```sql
select * from user_info where name = 'abc'
```

![img](https://gitee.com/abin_z/pic_bed/raw/master/3575048-7869c8d86f5f345b.png)





### 5.5 复合索引和单列索引

 **单列索引**，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引；

 **组合索引**，两个或更多个列上的索引被称作联合索引，组合索引又叫联合索引

唯一索引与普通索引类似，不同的就是：**索引列的值必须唯一，但允许有空值**。如果是组合索引，则列值的组合必须唯一

复合索引的结构:

![image-20220309124349595](https://gitee.com/abin_z/pic_bed/raw/master/image-20220309124349595.png)

使用组合索引时需要注意的问题: 

**MySQL组合索引“==最左前缀==”的结果。简单的理解就是只从最左面的开始组合**. 需要结合复合索引的数据结构进行理解!

比如说创建了以下的 **组合索引  (a, b, c)** , 那么存在以下的排列组合:

| 排列组合(精确匹配) | 是否用到组合索引                                 |
| ------------------ | ------------------------------------------------ |
| a, b, c            | a,b,c，恭喜成功命中索引, 使用了复合索引的全部    |
| a, c, b            | a,c,b，恭喜成功命中索引, 使用了复合索引的全部    |
| c, a, b            | c,a,b，恭喜成功命中索引, 使用了复合索引的全部    |
| c, b, a            | c,b,a，恭喜成功命中索引, 使用了复合索引的全部    |
| b, c, a            | b,c,a，恭喜成功命中索引, 使用了复合索引的全部    |
| a, b               | a,b，恭喜成功命中索引, 使用了复合索引的a, b 部分 |
| b, a               | b,a，恭喜成功命中索引, 使用了复合索引的a, b 部分 |
| a, c               | a,c，恭喜成功命中索引, 使用了复合索引的a部分     |
| c, a               | c,a，恭喜成功命中索引, 使用了复合索引的a部分     |
| b, c               | b,c，很遗憾全表扫描了, 索引失效                  |
| a                  | a，恭喜成功命中索引, 使用了复合索引的a部分       |
| b                  | b，很遗憾全表扫描了, 索引失效                    |
| c                  | c，很遗憾全表扫描了, 索引失效                    |

结论: 

1. **当所有字段都在where条件上, 组合索引字段无论顺序如何改变都会用到索引,** **SQL优化器会自动调整顺序.**
2. **如果想要使用一个或者两个字段在where条件上，必须有组合索引里的第一个字段，但是与顺序无关，例如a,c或c,a，这种场景是可以命中索引的**。但是，b,c或c,b这种是不会命中索引的。
3. **如果组合索引存在范围查询，则组合索引可能会命中索引**，这个跟B+Tree的叶子节点中存储的数据是否在当前的叶子节点中，即InnoDB存储引擎的最小存储单元——页，InnoDB页的大小默认是16k，可以通过参数查看页的默认大小：`show global status like ‘innodb_page_size’`;如果想要修改InnoDB页的大小，需要通过修改mysql源码才可以修改，找到源码文件(storage/innobase/include/univ.i)，找到参数：UNIV_PAGE_SIZE，该参数必须是2的n次方，例如4k、8k、16k、32k、64k等等。
4. order by 只能使用a，才能用到索引.   group by子句执行时会先排序，再分组。

**group by 分组操作示意图**: 

![bda5cd74gy1frhxeblz75j20ud0gg3zp](https://gitee.com/abin_z/pic_bed/raw/master/bda5cd74gy1frhxeblz75j20ud0gg3zp.jpg)





## 6.索引的缺点

 ◆**虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE和DELETE。**

​	因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。

**◆建立索引会占用磁盘空间的索引文件。**

​    一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。



## 7.使用索引注意事项



#### 7.1 不要在列上使用函数和进行运算

**==不要在列上使用函数==**，这将导致索引失效而进行全表扫描。

```sql
select * from news where year(publish_time) < 2017
```

为了使用索引，防止执行全表扫描，可以进行改造。

```sql
select * from news where publish_time < '2017-01-01'
```

还有一个建议，**==不要在列上进行运算==**，这也将导致索引失效而进行全表扫描。

```sql
select * from news where id / 100 = 1
```

为了使用索引，防止执行全表扫描，可以进行改造。

```sql
select * from news where id = 1 * 100
```



#### 7.2 尽量避免使用 != 或 not in或 <> 等否定操作符

**应该==尽量避免在 where 子句中使用 != 或 not in 或 <> 操作符==，因为这几个操作符都会导致索引失效而进行全表扫描。**



#### 7.3 尽量避免使用 or 来连接条件

应该**尽量避免在 where 子句中使用 or 来连接条件**，因为这会导致索引失效而进行全表扫描。

```sql
select * from news where id = 1 or id = 2
```



#### 7.4 多个单列索引并不是最佳选择

**==MySQL 只能使用一个索引==，会从多个索引中选择一个限制最为严格的索引**，因此，为多个列创建单列索引，并不能提高 MySQL 的查询性能。

注意: **索引合并，让一条sql可以使用多个索引(原理是将多个索引合并为一个索引,再使用这个索引)**。对这些索引取交集，并集，或者先取交集再取并集。从而减少从数据表中取数据的次数，提高查询效率。

> 引用其中的一句话："与其说是数据库只支持一条查询语句只使用一个索引，倒不如说N条独立索引同时在一条语句使用的消耗比只使用一个索引还要慢。"

假设，有两个单列索引，分别为 news_year_idx(news_year) 和 news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL 语句可以写成：

```sql
select * from news where news_year = 2017 and news_month = 1
```

**事实上，MySQL 只能使用一个单列索引**。为了提高性能，可以使用复合索引 news_year_month_idx(news_year, news_month) 保证 news_year 和 news_month 两个列都被索引覆盖。



#### 7.5 复合索引的最左前缀原则

**复合索引遵守“==最左前缀==”原则，即在查询条件中使用了复合索引的第一个字段(多列索引以此类推)，索引才会被使用**。因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。

假设，有一个场景只需要针对资讯的月份进行查询，那么，SQL 语句可以写成：

```sql
select * from news where news_month = 1
```

此时，无法使用 news_year_month_idx(news_year, news_month) 索引，因为遵守“最左前缀”原则，在查询条件中没有使用复合索引的第一个字段，索引是不会被使用的。



#### 7.6 覆盖索引的好处

**如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大的提高性能**。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。



#### 7.7 范围查询对多列查询的影响

**==查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。==**

举个例子，假设有一个场景需要查询本周发布的资讯文章，其中的条件是必须是启用状态，且发布时间在这周内。那么，SQL 语句可以写成：

```sql
select * from news where publish_time >= '2017-01-02' and publish_time <= '2017-01-08' and enable = 1
```

这种情况下，因为范围查询对多列查询的影响，将导致 news_publish_idx(publish_time, enable) 索引中 publish_time 右边所有列都无法使用索引优化查找。换句话说，news_publish_idx(publish_time, enable) 索引等价于 news_publish_idx(publish_time) 。

对于这种情况，建议是：**对于范围查询，务必要注意它带来的副作用，并且尽量少用范围查询，可以通过曲线救国的方式满足业务场景。**

例如，上面案例的需求是查询本周发布的资讯文章，因此可以创建一个news_weekth 字段用来存储资讯文章的周信息，使得范围查询变成普通的查询，SQL 可以改写成：

```sql
select * from news where     news_weekth = 1 and enable = 1
```

然而，并不是所有的范围查询都可以进行改造，对于必须使用范围查询但无法改造的情况，建议是：**不必试图用 SQL 来解决所有问题，可以使用其他数据存储技术控制时间轴，例如 Redis 的 SortedSet 有序集合保存时间，或者通过缓存方式缓存查询结果从而提高性能。**



#### 7.8 索引不会包含有NULL值的列

**只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。**

因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。



#### 7.9 隐式转换的影响

**==当查询条件左右两侧数据类型不匹配的时候会发生隐式转换==，隐式转换带来的影响就是可能导致索引失效而进行全表扫描**。下面的案例中，date_str 是字符串，然而匹配的是整数类型，从而发生隐式转换。

```
select * from news where date_str = 201701    
```

因此，**要谨记隐式转换的危害**，时刻注意通过同类型进行比较。



#### 7.10 like 语句的索引失效问题

**like 的方式进行查询，在 ==like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询==**，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用 ElasticSearch 或 Solr 是个不错的方案。



####  **7.11 使用短索引**

 **对串列进行索引，如果可能应该指定一个前缀长度**。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。



# 四. 执行计划 Explain

explain 命令获取 select 语句的执行计划

```sql
explain [select语句]

mysql> EXPLAIN SELECT * FROM one o,two t, three r WHERE o.two_id = t.two_id AND t.three_id = r.three_id;
```

**通过 explain 命令获取 select 语句的执行计划**，通过 explain 可以知道 select 语句以下信息：

- 表的加载顺序
- sql 的查询类型
- 可能用到哪些索引，**实际上用到哪些索引**
- 表与表之间的引用关系
- 一个表中有多少行被优化器查询 
- ...



**explain 执行计划包含字段信息如下：分别是 `id`、`select_type`、`table`、`partitions`、`type`、`possible_keys`、`key`、`key_len`、`ref`、`rows`、`filtered`、`Extra` 12个字段。**

![image-20220307135105084](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307135105084.png)

## 1. id

`id：` ：表示查询中执行select子句或者操作表的顺序，**==id的值越大，代表优先级越高，越先执行==**。一般会出现3种情况:

创建三张表 `one`、`two`、`three`，表之间的关系 `one.two_id = two.two_id AND two.three_id = three.three_id`。

#### 1.1 id相同

**具有同样的优先级，执行顺序由上而下，具体顺序由优化器决定**。

```sql
EXPLAIN SELECT * FROM one o,two t, three r WHERE o.two_id = t.two_id AND t.three_id = r.three_id;
```

```sql
mysql> EXPLAIN SELECT * FROM one o,two t, three r WHERE o.two_id = t.two_id AND t.three_id = r.three_id;
+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                  | rows | filtered | Extra                                              |
+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | o     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL                 |    2 |      100 | NULL                                               |
|  1 | SIMPLE      | t     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL                 |    2 |       50 | Using where; Using join buffer (Block Nested Loop) |
|  1 | SIMPLE      | r     | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xin-slave.t.three_id |    1 |      100 | NULL                                               |
+----+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+----------------------------------------------------+
```

![image-20220307140007231](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307140007231.png)

可以看到三条记录的id都相同, 都是1, 可以理解成这三个表为一组，具有同样的优先级，执行顺序由上而下，具体顺序由优化器决定。



#### 1.2 id不同

如果我们的 `SQL` 中存在子查询，那么 `id`的序号会递增，**id值越大优先级越高，越先被执行** 。当三个表依次嵌套，发现最里层的子查询 `id`最大，最先执行。

```sql
EXPLAIN select * from one o where o.two_id = (select t.two_id from two t where t.three_id = (select r.three_id  from three r where r.three_name='我是第三表2'));
```

```sql
mysql> EXPLAIN select * from one o where o.two_id = (select t.two_id from two t where t.three_id = (select r.three_id  from three r where r.three_name='我是第三表2'));
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | PRIMARY     | o     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |
|  2 | SUBQUERY    | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |
|  3 | SUBQUERY    | r     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |       50 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
```

![image-20220307140852891](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307140852891.png)

如果我们的 `SQL` 中存在子查询，那么 `id`的序号会递增，`id`值越大优先级越高，越先被执行 。当三个表依次嵌套，发现最里层的子查询 `id`最大，最先执行。

#### 1.3 相同和不相同的id均存在

将上边的 `SQL` 稍微修改一下，增加一个子查询，发现 `id`的以上两种同时存在。相同`id`划分为一组，这样就有三个组，同组的从上往下顺序执行，不同组 `id`值越大，优先级越高，越先执行。

```sql
EXPLAIN select * from one o where o.two_id = (select t.two_id from two t where t.three_id = (select r.three_id  from three r where r.three_name='我是第三表2')) AND o.one_id in(select one_id from one where o.one_name="我是第一表2");
```

```sql
mysql>  EXPLAIN select * from one o where o.two_id = (select t.two_id from two t where t.three_id = (select r.three_id  from three r where r.three_name='我是第三表2')) AND o.one_id in(select one_id from one where o.one_name="我是第一表2");
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref                | rows | filtered | Extra       |
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+
|  1 | PRIMARY     | o     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL               |    2 |       50 | Using where |
|  1 | PRIMARY     | one   | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xin-slave.o.one_id |    1 |      100 | Using index |
|  2 | SUBQUERY    | t     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               |    2 |       50 | Using where |
|  3 | SUBQUERY    | r     | NULL       | ALL    | NULL          | NULL    | NULL    | NULL               |    2 |       50 | Using where |
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------------+------+----------+-------------+

```

![image-20220307141231588](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307141231588.png)

将上边的 `SQL` 稍微修改一下，增加一个子查询，发现 `id`的以上两种同时存在。相同`id`划分为一组，这样就有三个组，同组的从上往下顺序执行，不同组 `id`值越大，优先级越高，越先执行。

## 2. select_type

**`select_type`：表示 `select` 查询的类型**，主要是用于区分各种复杂的查询，例如：`普通查询`、`联合查询`、`子查询`等。

1.  **SIMPLE**    (简单SELECT,不使用UNION或子查询等)
2.  **PRIMARY**   (查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)
3.  **UNION**    (UNION中的第二个或后面的SELECT语句)
4.  **DEPENDENT** **UNION**    (UNION中的第二个或后面的SELECT语句，取决于外面的查询)
5.  **UNION** **RESULT**   (UNION的结果)
6.  **SUBQUERY**   (子查询中的第一个SELECT)
7.  **DEPENDENT SUBQUERY**   (子查询中的第一个SELECT，取决于外面的查询)
8.  **DERIVED**    (派生表的SELECT, FROM子句的子查询)
9.  **UNCACHEABLE SUBQUERY**   (一个子查询的结果不能被缓存，必须重新评估外链接的第一行)



#### 2.1 SIMPLE

`SIMPLE`：**表示最简单的 select 查询语句**，也就是在查询中不包含子查询或者 `union`交并差集等操作。

#### 2.2 PRIMARY

`PRIMARY`：当查询语句中包含任何复杂的子部分，**最外层查询**则被标记为`PRIMARY`。

#### 2.3 SUBQUERY

`SUBQUERY`：当 `select` 或 `where` 列表中包含了子查询，该**子查询**被标记为：`SUBQUERY` 。

#### 2.4 DERIVED

`DERIVED`：表示包含在`from`子句中的子查询的select，**在我们的 `from` 列表中包含的子查询会被标记为`derived` 。**

#### 2.5 UNION

`UNION`：**如果`union`后边又出现的`select` 语句，则会被标记为`union`；若 `union` 包含在 `from` 子句的子查询中，外层 `select` 将被标记为 `derived`。**

#### 2.6 UNION RESULT

`UNION RESULT`：代表从`union`的临时表中读取数据，而`table`列的`<union1,4>`表示用第一个和第四个`select`的结果进行`union`操作。

```sql
mysql> EXPLAIN select t.two_name, ( select one.one_id from one) o from (select two_id,two_name from two where two_name ='') t  union (select r.three_name,r.three_id from three r);
```

```sql
mysql> EXPLAIN select t.two_name, ( select one.one_id from one) o from (select two_id,two_name from two where two_name ='') t  union (select r.three_name,r.three_id from three r);

+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+
| id   | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |
+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+
|    1 | PRIMARY      | two        | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |       50 | Using where     |
|    2 | SUBQUERY     | one        | NULL       | index | NULL          | PRIMARY | 4       | NULL |    2 |      100 | Using index     |
|    4 | UNION        | r          | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |    2 |      100 | NULL            |
| NULL | UNION RESULT | <union1,4> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL | NULL     | Using temporary |
+------+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+

```

![image-20220307142255463](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307142255463.png)

## 3.table

**查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表**，例如上边的`DERIVED`、 `<union1,4>`等。



## 4.partitions

查询时匹配到的分区信息，对于非分区表值为`NULL`，当查询的是分区表时，`partitions`显示分区表命中的分区情况。

![image-20220307142736760](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307142736760.png)

```sql
+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table          | partitions                      | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | one            | p201801,p201802,p201803,p300012 | index | NULL          | PRIMARY | 9       | NULL |    3 |      100 | Using index |
+----+-------------+----------------+---------------------------------+-------+---------------+---------+---------+------+------+----------+-------------+
```



## 5.type *

**type：查询使用了何种类型，它在 `SQL`优化中是一个非常重要的指标**，以下性能从好到坏依次是：

`system`  > `const` > `eq_ref` > `ref`  > `ref_or_null` > `index_merge` > `unique_subquery` > `index_subquery` > `range` > `index` > `ALL`

**ALL**：Full Table Scan， MySQL将遍历全表以找到匹配的行

**index**: Full Index Scan，index与ALL区别为index类型只遍历索引树

**range**:只检索给定范围的行，使用一个索引来选择行

**ref**: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

**eq_ref**: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件

**const**、**system**: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system



#### 5.1 system

`system`： 当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快。比如，Mysql系统表proxies_priv在Mysql服务启动时候已经加载在内存中，对这个表进行查询不需要进行磁盘 IO。

![preview](https://gitee.com/abin_z/pic_bed/raw/master/v2-48b919d21ca0271e1bfc61cb40b31c02_r.jpg)



#### 5.2const

`const`：**表示查询时命中 `primary key` 主键或者 `unique` 唯一索引，或者被连接的部分是一个常量(`const`)值**。这类扫描效率极高，返回数据量少，速度非常快。

```sql
EXPLAIN SELECT * from three where three_id=1;
```

![image-20220307144059666](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307144059666.png)

```sql
mysql> EXPLAIN SELECT * from three where three_id=1;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | three | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |      100 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
```



#### 5.3 eq_ref

`eq_ref`：**多表关联**查询的时候，**==主键和唯一索引==作为关联条件。查询时命中主键`primary key` 或者 `unique key`索引**， `type` 就是 `eq_ref`。对于user表（外循环）的每一行，user_role表（内循环）只有一行满足join条件，只要查找到这行记录，就会跳出内循环，继续外循环的下一轮查询。

![preview](https://pic3.zhimg.com/v2-eb83ba64a69c5f79306bb96bf78db7c6_r.jpg)

```sql
EXPLAIN select o.one_name from one o ,two t where o.one_id = t.two_id ; 
```

![image-20220307144034496](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307144034496.png)

```sql
mysql> EXPLAIN select o.one_name from one o ,two t where o.one_id = t.two_id ; 
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref                | rows | filtered | Extra       |
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+
|  1 | SIMPLE      | o     | NULL       | index  | PRIMARY       | idx_name | 768     | NULL               |    2 |      100 | Using index |
|  1 | SIMPLE      | t     | NULL       | eq_ref | PRIMARY       | PRIMARY  | 4       | xin-slave.o.one_id |    1 |      100 | Using index |
+----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-------------+

```



#### 5.4 ref

`ref`：区别于`eq_ref` **，`ref`表示使用非唯一性索引，会找到很多个符合条件的行。**

查找条件列**==使用了索引而且不为主键和唯一索引==**。虽然使用了索引，但该索引列的值并不唯一，这样**即使使用索引查找到了第一条数据，仍然不能停止，要在目标值附近进行小范围扫描。**但它的好处是不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内做扫描。

![image-20220307144002845](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307144002845.png)

```sql
mysql> select o.one_id from one o where o.one_name = "xin" ; 
+--------+
| one_id |
+--------+
|      1 |
|      3 |
+--------+
```

```sql
mysql> EXPLAIN select o.one_id from one o where o.one_name = "xin" ; 
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | o     | NULL       | ref  | idx_name      | idx_name | 768     | const |    1 |      100 | Using index |
+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+
```



#### 5.5 ref_or_null

`ref_or_null`：这种连接类型类似于 ref，**区别在于 `MySQL`会额外搜索包含`NULL`值的行。**

![image-20220307143918591](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307143918591.png)

```sql
mysql> EXPLAIN select o.one_id from one o where o.one_name = "xin" OR o.one_name IS NULL; 
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+
| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+
|  1 | SIMPLE      | o     | NULL       | ref_or_null | idx_name      | idx_name | 768     | const |    3 |      100 | Using where; Using index |
+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+--------------------------+

```



#### 5.6 index_merge

`index_merge`：**使用了索引合并优化方法，查询使用了两个以上的索引。**

下边示例中同时使用到主键`one_id` 和 字段`one_name`的`idx_name` 索引 。

![image-20220307144239929](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307144239929.png)

```sql
mysql> EXPLAIN select * from one o where o.one_id >1 and o.one_name ='xin'; 
+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+
| id | select_type | table | partitions | type        | possible_keys    | key              | key_len | ref  | rows | filtered | Extra                                          |
+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+
|  1 | SIMPLE      | o     | NULL       | index_merge | PRIMARY,idx_name | idx_name,PRIMARY | 772,4   | NULL |    1 |      100 | Using intersect(idx_name,PRIMARY); Using where |
+----+-------------+-------+------------+-------------+------------------+------------------+---------+------+------+----------+------------------------------------------------+
```



#### 5.7 unique_subquery

`unique_subquery`：替换下面的 `IN`子查询，子查询返回不重复的集合。

```sql
value IN (SELECT primary_key FROM single_table WHERE some_expr)
```

#### 5.8 index_subquery

`index_subquery`：区别于`unique_subquery`，用于非唯一索引，可以返回重复值。

```sql
value IN (SELECT key_column FROM single_table WHERE some_expr)
```



#### 5.9 range

`range`：==使用索引选择行，仅检索给定范围内的行==。简单点说就是针对一个**有索引的字段**，给定范围检索数据。在`where`语句中使用 `bettween...and`、`<`、`>`、`<=`、`in` 等条件查询 `type` 都是 `range`。

举个栗子：`three`表中`three_id`为唯一主键，`user_id`普通字段未建索引。

```sql
mysql> EXPLAIN SELECT * from three where three_id BETWEEN 2 AND 3;
```

![image-20220307144634908](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307144634908.png)

```sql
mysql> EXPLAIN SELECT * from three where three_id BETWEEN 2 AND 3;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | three | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    1 |      100 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
```



user_id 字段没有索引， 所以type不是 range ，而是全文检索 ALL 

所以**只有对设置了索引的字段，做范围检索 `type` 才是 `range`。**

```sql
mysql> EXPLAIN SELECT * from three where user_id BETWEEN 2 AND 3;
```

![image-20220307144907440](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307144907440.png)

```sql
mysql> EXPLAIN SELECT * from three where user_id BETWEEN 2 AND 3;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | three | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
```



#### 5.10 index

**index包括select索引列，order by主键两种情况。**

order by主键。这种情况会按照索引顺序全表扫描数据，拿到的数据是按照主键排好序的，不需要额外进行排序。

![preview](https://pic1.zhimg.com/v2-ccc6410ca9edbda2eb84144125d4e17c_r.jpg)

select索引列。type为index，而且extra字段为using index，也称这种情况为**索引覆盖**。所需要取的数据都在索引列，无需回表查询。

![preview](https://gitee.com/abin_z/pic_bed/raw/master/v2-ac2d258067814b0fe68a819839773ca7_r.jpg)



`index`：`Index` 与`ALL` 其实都是读全表，区别在于`index`是遍历索引树读取，而`ALL`是从硬盘中读取。

下边示例：`three_id` 为主键，不带 `where` 条件全表查询 ，`type`结果为`index` 。

```sql
mysql> EXPLAIN SELECT three_id from three ;
```

![image-20220307145656193](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307145656193.png)

```sql
mysql> EXPLAIN SELECT three_id from three ;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | three | NULL       | index | NULL          | PRIMARY | 4       | NULL |    1 |      100 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
```



#### 5.11 ALL

`ALL`：将遍历全表以找到匹配的行，性能最差。

```sql
mysql> EXPLAIN SELECT * from two ;
```

![image-20220307145810003](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307145810003.png)

```sql
mysql> EXPLAIN SELECT * from two ;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | two   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
```



## 6.possible_keys

`possible_keys`：表示在`MySQL`中可能通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，**但这个索引并不定一会是最终查询数据时所被用到的索引**。具体请参考上边的例子。



## 7.key

`key`：区别于`possible_keys`，key是**查询中实际使用到的索引**，若没有使用索引，显示为`NULL`。具体请参考上边的例子。

当 `type` 为 `index_merge` 时，可能会显示多个索引。



## 8.key_len

`key_len`：表示查询用到的索引长度（字节数），**不损失精确性的情况下，长度越短越好  。**

- **单列索引，那么需要将整个索引长度算进去；**
- **==多列索引/复合索引，不是所有列都能用到，需要计算查询中实际用到的列。==**

注意：**`key_len`只计算`where`条件中用到的索引长度**，而排序和分组即便是用到了索引，也不会计算到`key_len`中。



## 9.ref

`ref`：常见的有：`const`，`func`，`null`，字段名。

- 当使用常量等值查询，显示`const`，
- 当关联查询时，会显示相应关联表的`关联字段`
- **如果查询条件使用了`表达式`、`函数`，或者条件列发生内部隐式转换，可能显示为`func`**
- 其他情况`null`



## 10.rows

`rows`：以表的统计信息和索引使用情况，**估算要找到我们所需的记录，需要读取的行数。**

这是评估`SQL` 性能的一个比较重要的数据，**`mysql`需要扫描的行数，很直观的显示 `SQL` 性能的好坏**，一般情况下 `rows` 值越小越好。说

```sql
mysql> EXPLAIN SELECT * from three;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | three | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
```



## 11.filtered

`filtered` 这个是一个百分比的值，表里符合条件的记录数的百分比。简单点说，**这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例。** 100% 则说明存储引擎返回的数据全部符合要求, 效果最好.

```sql
在MySQL.5.7版本以前想要显示filtered需要使用explain extended命令。MySQL.5.7后，默认explain直接显示partitions和filtered的信息。
```



## 12.Extra

`Extra` ：不适合在其他列中显示的信息，`Explain` 中的很多额外的信息会在 `Extra` 字段显示。

#### 12.1 Using index

`Using index`：我们在相应的 `select` 操作中使用了覆盖索引，通俗一点讲**就是查询的列被索引覆盖，使用到覆盖索引查询速度会非常快，`SQl`优化中理想的状态。**

覆盖索引:   一条 `SQL`只需要通过索引就可以返回，我们所需要查询的数据（一个或几个字段），而不必通过二级索引

案例: `one_id`表为主键

```sql
mysql> EXPLAIN SELECT one_id from one ;			# 使用了索引覆盖 Extra = Using index
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | one   | NULL       | index | NULL          | idx_two_id | 5       | NULL |    3 |      100 | Using index |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
```

**注意**：想要使用到覆盖索引，我们在 `select` 时只取出需要的字段，不可`select *`，而且该字段建了索引。

```sql
mysql> EXPLAIN SELECT * from one ;		# 没有用到索引覆盖 Extra = NULL
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
```



#### 12.2 Using where

`Using where`：**查询时未找到可用的索引，进而通过`where`条件过滤获取所需数据**，但要注意的是并不是所有带`where`语句的查询都会显示`Using where`。

下边示例`create_time` 并未用到索引，`type` 为 `ALL`，即`MySQL`通过全表扫描后再按`where`条件筛选数据。

```sql
mysql> EXPLAIN SELECT one_name from one where create_time ='2020-05-18';
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
```



#### 12.3 Using temporary

`Using temporary`：**表示查询后结果需要使用临时表来存储，一般在排序或者分组查询时用到。**常见于 order by 和 group by 中。典型的，当group by和order by同时存在，且作用于不同的字段时，就会建立临时表，以便计算出最终的结果集。

![image-20220307152822337](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307152822337.png)

```sql
mysql> EXPLAIN SELECT one_name from one where one_id in (1,2) group by one_name;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | one   | NULL       | range| NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using temporary; Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
```



#### 12.4 Using filesort

`Using filesort`**：表示无法利用索引完成的排序操作，也就是`ORDER BY`的字段没有索引，通常这样的SQL都是需要优化的。**

文件排序。表示无法利用索引完成排序操作，以下情况会导致filesort：

- order by 的字段不是索引字段
- select 查询字段不全是索引字段
- select 查询字段都是索引字段，但是 order by 字段和索引字段的顺序不一致

```sql
mysql> EXPLAIN SELECT one_id from one  ORDER BY create_time;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | one   | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |      100 | Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
```

如果`ORDER BY`字段有索引就会用到覆盖索引，相比执行速度快很多。

```sql
mysql> EXPLAIN SELECT one_id from one  ORDER BY one_id;				# 使用到了索引覆盖 Extra =  Using index 
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | one   | NULL       | index | NULL          | PRIMARY | 4       | NULL |    3 |      100 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
```



#### 12.5 Using join buffer

`Using join buffer`：在我们联表查询的时候，**如果表的连接条件没有用到索引，需要有一个连接缓冲区来存储中间结果**。

**==Block Nested Loop，需要进行嵌套循环计算。==**两个关联表join，关联字段均未建立索引，就会出现这种情况。比如内层和外层的type均为ALL，rows均为4，需要循环进行4*4次计算。常见的优化方案是，在关联字段上添加索引，避免每次嵌套循环计算。

**先看一下有索引的情况**：连接条件 `one_name` 、`two_name` 都用到索引。

```sql
mysql> EXPLAIN SELECT one_name from one o,two t where o.one_name = t.two_name;
```

![image-20220307153416368](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307153416368.png)

```sql
mysql> EXPLAIN SELECT one_name from one o,two t where o.one_name = t.two_name;
+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref                  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+
|  1 | SIMPLE      | o     | NULL       | index | idx_name      | idx_name | 768     | NULL                 |    3 |      100 | Using where; Using index |
|  1 | SIMPLE      | t     | NULL       | ref   | idx_name      | idx_name | 768     | xin-slave.o.one_name |    1 |      100 | Using index              |
+----+-------------+-------+------------+-------+---------------+----------+---------+----------------------+------+----------+--------------------------+

```

接下来删掉 连接条件 `one_name` 、`two_name` 的字段索引。发现`Extra` 列变成 `Using join buffer`，`type`均为全表扫描，这也是`SQL`优化中需要注意的地方。

![image-20220307153546201](https://gitee.com/abin_z/pic_bed/raw/master/image-20220307153546201.png)

```sql
mysql> EXPLAIN SELECT one_name from one o,two t where o.one_name = t.two_name;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |      100 | NULL                                               |
|  1 | SIMPLE      | o     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where; Using join buffer (Block Nested Loop) |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+

```

#### 12.6 Impossible where

`Impossible where`：表示在我们用不太正确的`where`语句，导致没有符合条件的行。

```sql
mysql> EXPLAIN SELECT one_name from one WHERE 1=2;
```

```sql
mysql> EXPLAIN SELECT one_name from one WHERE 1=2;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | Impossible WHERE |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
```



#### 12.7 No tables used

`No tables used`：我们的查询语句中没有`FROM`子句，或者有 `FROM DUAL`子句。

```sql
mysql> EXPLAIN select now();
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL     | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
```

`Extra`列的信息非常非常多，详见 `MySQL`官方文档 ： https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_index_merge

相关博客: https://juejin.cn/post/6844904163969630221#heading-7       

​				 https://zhuanlan.zhihu.com/p/396114960





# 五. 事务&隔离级别











