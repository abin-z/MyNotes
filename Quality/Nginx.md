# web的基本知识

#### web

web（World Wide Web）即全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。是建立在Internet上的一种网络服务，为浏览者在Internet上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet上的信息节点组织成一个互为关联的网状结构。



#### HTML

HTML的全称为[超文本标记语言](https://baike.baidu.com/item/超文本标记语言/6972570)，是一种[标记语言](https://baike.baidu.com/item/标记语言/5964436)。它包括一系列[标签](https://baike.baidu.com/item/标签/2440469)．通过这些标签可以将网络上的[文档](https://baike.baidu.com/item/文档/1009768)格式统一，使分散的[Internet](https://baike.baidu.com/item/Internet/272794)资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性[文本](https://baike.baidu.com/item/文本/5443630)，HTML命令可以说明[文字](https://baike.baidu.com/item/文字/612910)，[图形](https://baike.baidu.com/item/图形/773307)、[动画](https://baike.baidu.com/item/动画/206564)、[声音](https://baike.baidu.com/item/声音/33686)、[表格](https://baike.baidu.com/item/表格/3371820)、[链接](https://baike.baidu.com/item/链接/2665501)等



#### HTTP协议

**超文本传输协议**（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在[TCP](https://baike.baidu.com/item/TCP/33012)之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以[ASCII](https://baike.baidu.com/item/ASCII/309296)形式给出；而消息内容则具有一个类似[MIME](https://baike.baidu.com/item/MIME/2900607)的格式。这个简单模型是早期[Web](https://baike.baidu.com/item/Web/150564)成功的有功之臣，因为它使开发和部署非常地直截了当



#### HTTPS协议

HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和[身份认证](https://baike.baidu.com/item/身份认证/5294713)保证了传输过程的安全性 [1] 。HTTPS 在HTTP 的基础下加入[SSL](https://baike.baidu.com/item/SSL/320778)，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 [TCP](https://baike.baidu.com/item/TCP/33012) 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于[万维网](https://baike.baidu.com/item/万维网/215515)上安全敏感的通讯，例如交易支付等方面



#### SSL

SSL(Secure Sockets Layer **[安全套接字协议](https://baike.baidu.com/item/安全套接字协议)**),及其继任者[传输层安全](https://baike.baidu.com/item/传输层安全)（Transport Layer Security，TLS）是为[网络通信](https://baike.baidu.com/item/网络通信/9636548)提供安全及[数据完整性](https://baike.baidu.com/item/数据完整性/110071)的一种安全协议。TLS与SSL在[传输层](https://baike.baidu.com/item/传输层/4329536)与[应用层](https://baike.baidu.com/item/应用层/16412033)之间对网络连接进行加密。



#### Web1.0	

**(静态网站)---信息不实时更新**

web1.0时代是一个群雄并起，逐鹿网络的时代，虽然各个网站采用的手段和方法不同，但第一代[互联网](https://baike.baidu.com/item/互联网/199186)有诸多共同的特征，表现在技术创新主导模式、基于点击流量的盈利共通点、门户合流、明晰的主营兼营产业结构、动态网站。在WEB1.0上做出巨大贡献的公司有[Netscape](https://baike.baidu.com/item/Netscape/2778944)，[Yahoo](https://baike.baidu.com/item/Yahoo)和[Google](https://baike.baidu.com/item/Google)。 Netscape研发出第一个大规模商用的浏览器，Yahoo的[杨致远](https://baike.baidu.com/item/杨致远/709484)提出了互联网黄页， 而Google后来居上，推出了大受欢迎的搜索服务。



#### Web2.0

**用户参与,于网站交互--提供信息(数据)**

Web2.0是相对于[Web1.0](https://baike.baidu.com/item/Web1.0)的新的时代。指的是一个利用Web的平台，由用户主导而生成的内容互联网产品模式，为了区别传统由网站雇员主导生成的内容而定义为第二代[互联网](https://baike.baidu.com/item/互联网/199186)，web2.0是一个新的时代。 [1] 抛开纷繁芜杂的Web 2.0现象，进而将其放到科技发展与社会变革的大视野下来看，Web 2.0可以说是信息技术发展引发网络革命所带来的面向未来、以人为本的[创新2.0](https://baike.baidu.com/item/创新2.0)模式在互联网领域的典型体现，是由专业人员织网到所有用户参与织网的创新民主化进程的生动注释。



#### Web3.0

**智能化-----法律--法规--道德规范**

Web3.0只是由业内人员制造出来的概念词语，最常见的解释是，[网站](https://baike.baidu.com/item/网站/155722)内的信息可以直接和其他网站相关信息进行交互，能通过第三方信息平台同时对多家网站的信息进行整合使用；用户在互联网上拥有自己的数据，并能在不同网站上使用；完全基于web，用浏览器即可实现复杂系统程序才能实现的系统功能;用户数据审计后，同步于[网络数据](https://baike.baidu.com/item/网络数据/509706)。



#### cookies 

Cookie(储存在用户本地终端上的数据)，有时也用其复数形式 [Cookies](https://baike.baidu.com/item/Cookies/187064)。类型为“**小型文本文件**”，是某些网站为了辨别用户身份，进行[Session](https://baike.baidu.com/item/Session/479100)跟踪而储存在用户本地终端上的数据（通常经过加密），由用户[客户端](https://baike.baidu.com/item/客户端/101081)计算机暂时或永久保存的信息



#### session

Session(储存在服务端上的用户数据)：在计算机中，尤其是在网络应用中，称为“会话控制”。[Session对象](https://baike.baidu.com/item/Session对象/5250998)存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web页时，如果该用户还没有会话，则Web服务器将自动创建一个 Session对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。例如，如果用户指明不喜欢查看图形，就可以将该信息存储在Session对象中。有关使用Session 对象的详细信息，请参阅“ASP应用程序”部分的“管理会话”。注意会话状态仅在支持cookie的浏览器中保留。



#### Apache

Apache(音译为[阿帕奇](https://baike.baidu.com/item/阿帕奇/374191))是世界使用排名第一的Web[服务器](https://baike.baidu.com/item/服务器)软件。它可以运行在几乎所有广泛使用的[计算机平台](https://baike.baidu.com/item/计算机平台/2606037)上，由于其[跨平台](https://baike.baidu.com/item/跨平台/8558902)和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将[Perl](https://baike.baidu.com/item/Perl)/[Python](https://baike.baidu.com/item/Python)等[解释器](https://baike.baidu.com/item/解释器/10418965)编译到服务器中。



#### Tomcat

Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由[Apache](https://baike.baidu.com/item/Apache/6265)、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。



#### Nginx

Nginx是一款基于C语言开发的[轻量级](https://baike.baidu.com/item/轻量级/10002835)的[Web](https://baike.baidu.com/item/Web/150564) 服务器/[反向代理](https://baike.baidu.com/item/反向代理/7793488)服务器及[电子邮件](https://baike.baidu.com/item/电子邮件/111106)（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是**占有内存少，[并发](https://baike.baidu.com/item/并发/11024806)能力强**，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、[京东](https://baike.baidu.com/item/京东/210931)、[新浪](https://baike.baidu.com/item/新浪/125692)、[网易](https://baike.baidu.com/item/网易/185754)、[腾讯](https://baike.baidu.com/item/腾讯/112204)、[淘宝](https://baike.baidu.com/item/淘宝/145661)等。支持负载均衡



#### 正向代理

正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。



#### 反向代理

反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。



#### 负载均衡

负载均衡*（Load Balance）*其意思就是分摊到多个操作单元上进行执行，例如Web[服务器](https://baike.baidu.com/item/服务器/100571)、[FTP服务器](https://baike.baidu.com/item/FTP服务器)、[企业](https://baike.baidu.com/item/企业/707680)关键应用服务器和其它关键任务服务器等，从而共同完成工作任务



##  几种常用web服务器对比

| **对比项**   | **Apache** | **Nginx** | **Lighttpd** |
| ------------ | ---------- | --------- | ------------ |
| Proxy代理    | 非常好     | 非常好    | 一般         |
| Rewriter     | 好         | 非常好    | 一般         |
| Fcgi         | 不好       | 好        | 非常好       |
| 热部署       | 不支持     | 支持      | 不支持       |
| 系统压力     | 很大       | 很小      | 比较小       |
| 稳定性       | 好         | 非常好    | 不好         |
| 安全性       | 好         | 一般      | 一般         |
| 静态文件处理 | 一般       | 非常好    | 好           |
| 反向代理     | 一般       | 非常好    | 一般         |







# Nginx

　Nginx是一款自由的、开源的、==高性能==的HTTP服务器和==反向代理==服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为==反向代理==进行==负载均衡==的实现。

基本概念:    https://www.cnblogs.com/wcwnina/p/8728391.html

## 1. 正向代理

**正向代理（forward proxy）**：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。

![image-20211201144838346](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011448415.png)

![image-20211201142943133](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011430053.png)

我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，知名的科学上网工具shadowsocks 扮演的就是典型的正向代理角色

总结来说：**正向代理，"它代理的是客户端，代客户端发出请求"**，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。==客户端必须要进行一些特别的设置才能使用正向代理==。



**正向代理的用途**：
（1）访问原来无法访问的资源，如Google
（2）可以做缓存，加速访问资源
（3）对客户端访问授权，上网进行认证
（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息





## 2. 反向代理

反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器

![image-20211201145050777](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011450859.png)



![image-20211201143006761](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011430950.png)

通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色。

　　客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为==客户端不需要任何配置就可以访问==。

　　**反向代理，"它代理的是服务端，代服务端接收请求"**，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。

**反向代理的作用**：
（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网
（2）负载均衡，通过反向代理服务器来优化网站的负载



## 3. 项目场景

正向代理和反向代理实际应用中是非常广泛的: 通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下：

![image-20211201142544243](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011425392.png)



## 4. 正向代理和反向代理的区别:

1. **代理的位置不同**

   正向代理，架设在客户机和目标主机之间；

   反向代理，架设在服务器端；

2. **代理的对象不同**

   正向代理，代理客户端，服务端不知道实际发起请求的客户端；

   反向代理，代理服务端，客户端不知道实际提供服务的服务端；

3. **用途不同**

   正向代理，为在防火墙内的局域网客户端提供访问Internet的途径；

   反向代理，将防火墙后面的服务器提供给Internet访问

4. **安全性不同**

   正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此必须采取安全措施以确保仅为授权的客户端提供服务；

   反向代理都对外都是透明的，访问者并不知道自己访问的是哪一个代理。

## 5. 负载均衡

负载均衡，英文名称为**Load Balance**，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。

负载均衡构建在原有网络结构之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性。

![preview](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011459147.jpeg)

Nginx常见的负载均衡算法: **轮询, 权重, ip_hash, 随机**



## 6. 动静分离	

![image-20211201145428931](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011454047.png)





# Nginx基本使用

## 1. docker中安装Nginx

Nginx的默认端口号是	80

```bash
docker pull nginx			#docker 拉取最新版的Nginx
docker run --name nginx --restart always -p 80:80 -d nginx		#创建并运行Nginx, 默认端口为80
```

![image-20210923105652266](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011543458.png)

进入docker容器中

默认的html文本存放路径

```bash
docker exec -it nginx bash				#进入Nginx容器中
cd /usr/share/nginx/html				#查看欢迎页面的html
cat index.html
```

Nginx的配置文件1: nginx.conf

``` bash
cd /etc/nginx/							#打开相应的路径
cat nginx.conf							#nginx配置文件
```

Nginx的配置文件2: default.conf

```bash
cd /etc/nginx/conf.d					#存放其他的配置文件的路径
cat default.conf						#Nginx配置文件
```



## 2. Nginx常用命令

```sh
cd /usr/local/nginx/sbin
./nginx				#启动
./nginx -s stop 	#停止
./nginx -s quit 	#安全退出
./nginx	-s reload	#重新加载配置文件
ps aux|grep nginx	#查看nginx的进程
```

![image-20211201151429895](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011514981.png)



### 1. 将自己的前端界面部署在Nginx上

将demo文件夹中的文件js和html等复制到/usr/share/nginx/html中

然后再浏览器中输入Linux机器的ip地址(默认为80端口)

![image-20210923142835476](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011543784.png)



### 2. 在Linux上部署后端项目

将idea中的项目打包(maven打包) 在target目录中会产生一个.jar的包

将.jar包拷贝到Linux服务器上,执行如下命令:

```bash
java -jar javaApp-1.0.jar						#当前窗口独占运行jar任务
java -jar javaApp-1.0.jar >> javaApp.log & 		#后台运行项目并将日志文件重定向到javaApp.log 中
```

注意: 需要修改前端的相关的请求ip地址(改为当前服务器的地址)  my.js

![image-20210923152052759](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011543391.png)



在浏览器中访问:

![image-20210923152208625](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011543952.png)

//至此项目的 前后端分离, 并且都部署在了Linux服务器上



**部署的相关技术要点**

* 在命令行部署的时候指定端口

* 可以在配置文件: application.properties中修改端口号:

  * 修改端口号

    ![image-20210923153036384](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011543766.png)

  * 设置web上下文路径

    ![image-20210923152924395](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011543202.png)



### 3. docker 容器中部署后端App

* 借助Dockerfile配置文件

* 依赖于本地Java的镜像



1. 下面是Dockerfile的内容(修改为自己相应的配置)

![image-20210923154508245](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011543882.png)



2. 根据Dockerfile配置文件创建自己的应用镜像

```dockerfile
docker build -t demo .				#注意后面有一个空格
```

![image-20210923155739797](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011543823.png)



3. run 一个javaAPP 的容器

```bash
docker run --name javaAPP --restart always -p 8080:8080 -d demo:latest 

docker run --name javaAPP1 --restart always -p 8081:8080 -d demo:latest 

docker run --name javaAPP2 --restart always -p 8082:8080 -d demo:latest 
```

//更改相应的端口号进行验证





## 3. Nginx负载均衡

创建多台Nginx的docker容器,并映射文件路径

首先配置从机slave

```bash
#对外端口为8001
docker run --name nginx_s1 --restart always -p 8001:80 -v /root/nginx/8001/html:/usr/share/nginx/html -d nginx

#对外端口为8002
docker run --name nginx_s2 --restart always -p 8002:80 -v /root/nginx/8002/html:/usr/share/nginx/html -d nginx

#对外端口为8003
docker run --name nginx_s3 --restart always -p 8003:80 -v /root/nginx/8003/html:/usr/share/nginx/html -d nginx
```

配置主机

```bash
#将准备好的配置文件映射进去.需要修改相应的参数(参考相关资料)
docker run --name nginx_m --restart always -p 80:80 -v /root/nginx/conf/default.conf:/etc/nginx/conf.d/default.conf -d nginx
```

配置文件: /etc/nginx/conf.d/default.conf

```bash
server
{
    listen  80;

    server_name 192.168.1.131;
    location /
    {
        proxy_pass http://www.abin.com;
    }

}

upstream www.abin.com
{
   server 192.168.1.131:8001;
   server 192.168.1.131:8002;
   server 192.168.1.131:8003;
}

```

![image-20210924103701213](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011542878.png)

默认情况下模式是: 轮询模式;   除此之外还需要将前端部署在每个Nginx的默认前端路径下

### Nginx自带的负载均衡算法

### **1. weight**

可以修改default.conf配置文件给相应的从机设置权重weight

```bash
server
{
    listen  80;

    server_name 192.168.1.131;
    location /
    {
        proxy_pass http://www.abin.com;
    }

}

upstream www.abin.com
{
   server 192.168.1.131:8001 weight=10;
   server 192.168.1.131:8002 weight=5;
   server 192.168.1.131:8003;			#不设置权重 则默认权重为1
}
```

![image-20210924104435473](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011542032.png)

### **2. ip_hash**

使用选项`  ip_hash`; 后, 每次访问的从机都是和第一次访问的从机一致

![image-20210924105520725](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011542288.png)

### **3. backup**

使用选项`backup`后, 正常情况下该台机器不会响应请求, 但是当其他Nginx服务器宕机后,则顶替上来

![image-20210924110529459](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011542514.png)



### **4. least_conn**

使用`least_conn`后, 会更加智能的处理响应, 那个服务器闲置越多,给它分发就越多

![image-20210924111254154](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/202112011542545.png)



依赖第三方的负载均衡算法插件:(参考相关资料)

https://blog.csdn.net/chenyulancn/article/details/70800991

**url_hash**  :根据请求的url的hash值将请求分到不同的机器中，当后台服务器为缓存的时候效率高。

**fair**   :根据后台响应时间来分发请求，响应时间短的分发的请求多。

**nginx配置详解:** https://www.runoob.com/w3cnote/nginx-setup-intro.html
