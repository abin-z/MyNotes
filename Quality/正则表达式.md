# Regular Expression

## 一. 正则表达式简介

正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为"元字符"）。

正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。它是一种字符串匹配的模式（pattern），更像是一种逻辑公式

![image-20220607105048426](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220607105048426.png)

## 二. 正则表达式语法

正则表达式的基本**组成元素**可以分为：==字符==和==元字符==。字符很好理解，就是基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母。而元字符，也被称为特殊字符，是一些用来表示特殊语义的字符。如^表示非,|表示或等。利用这些元字符，才能构造出强大的表达式模式(pattern)。

正则表达式是由**普通字符（例如字符 a 到 z）**以及**特殊字符（称为"元字符"）**组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。



### 1. 普通字符

普通字符包括**没有显式指定为元字符的所有可打印和不可打印字符**。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

|                     |                                                              |
| ------------------- | ------------------------------------------------------------ |
| **[ABC]**           | 匹配 **[...]** 中的所有字符，例如 **[aeiou]** 匹配字符串 "google runoob taobao" 中所有的 e o u a 字母。<br/>![img](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/E691DDE1-E5CB-4EA8-8D16-759BD0D2B09D.jpg) |
| **[^ABC]**          | 匹配除了 **[...]** 中字符的所有字符，例如 **[^aeiou]** 匹配字符串 "google runoob taobao" 中除了 e o u a 字母的所有字母。<br>![img](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/ED971D92-30F4-4768-A2C7-02A84A3A9DEB.jpg) |
| **[A-Z]**           | [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。<br>![img](https://www.runoob.com/wp-content/uploads/2014/03/C5E357BD-65E3-4EB3-9D80-10D096F19287.jpg) |
| **.**               | 匹配**除换行符（\n、\r）之外的任何单个字符**，相等于`[^\n\r]`。<br/>![img](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/0FD7E77D-38A7-43BC-B51A-7DBA23A77756.jpg) |
| **\d**              | 单个数字, [0-9]   **d**igit<br>![image-20220607123850178](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220607123850178.png) |
| **\D**              | 除了[0-9]       **not** **d**igit      和 \d 相反, 使用大写的\D     <br>![image-20220607124228030](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220607124228030.png) |
| **[\s\S]**          | 匹配所有。**\s 是匹配所有空白符，包括换行**，**\S 非空白符，不包括换行**。<br/>![img](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/47CA6C59-64CF-433A-909E-1E342349A4E0.jpg) |
| **\w**              | 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]<br/>![img](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/F35A5971-3519-4CAE-8BEC-9DE8F4A55257.jpg) |
| **\W**              | 非单字字符,       **not** **w**ord         和 \w 相反, 使用大写的\W    <br>![image-20220607124304883](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220607124304883.png) |
| **[\u4e00-\u9fa5]** | **仅匹配中文**字符时常会用到,  利用的是中文字符的Unicode编码在**[\u4e00-\u9fa5]**之间. (部分语言不支持)<br> \w 匹配的仅仅是中文，数字，字母, 和下划线<br>![image-20220610172628024](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610172628024.png) |
| **[^\x00-\xff]**    | **匹配双字节字符**(包括汉字在内)<br>![image-20220610173711686](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610173711686.png) |



### 2. 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 特殊字符       | RegEx | 描述                                                         | 记忆方式              |
| -------------- | ----- | ------------------------------------------------------------ | --------------------- |
| 换行符         | \n    | 匹配一个换行符。等价于 \x0a 和 \cJ。                         | **n**ew line          |
| 换页符         | \f    | 匹配一个换页符。等价于 \x0c 和 \cL。                         | **f**orm feed         |
| 回车符         | \r    | 匹配一个回车符。等价于 \x0d 和 \cM。                         | **r**eturn            |
| 空白符         | \s    | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 | **s**pace             |
| 任何非空白字符 | \S    | 匹配任何非空白字符。等价于 `[^ \f\n\r\t\v]`。                | 和\s 相反使用大写的\S |
| 制表符         | \t    | 匹配一个制表符。等价于 \x09 和 \cI。                         | **t**ab               |
| 垂直制表符     | \v    | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     | **v**ertical tab      |
| 回退符         | [\b]  | **b**ackspace,之所以使用[]符号是避免和\b重复                 | **b**ackspace         |




### 3. 特殊字符

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| \        | ==将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符==。例如 'n' 匹配字符 'n'。`\n`匹配换行符。序列 `\\`匹配 `\`，而 `\(` 则匹配 "("。 |
| ^        | ==匹配输入字符串的开始位置==，**除非在方括号表达式中使用**，**当该符号在方括号表达式中使用时，表示==不接受==该方括号表达式中的字符集合**。要匹配 ^ 字符本身，请使用 `\^`。 |
| $        | ==匹配输入字符串的结尾位置==。**如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'**。要匹配 $ 字符本身，请使用 `\$`。 |
| .        | ==匹配**除换行符 \n 之外**的任何单字符==。要匹配 . ，请使用 `\.` 。 |
| ( )      | ==标记一个子表达式的开始和结束位置==。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\(` 和 `\)`。 |
| ?        | ==匹配前面的子表达式零次或一次==，或==指明一个非贪婪限定符==。要匹配 ? 字符，请使用 `\?`。 |
| *        | ==匹配前面的子表达式零次或多次==。要匹配 * 字符，请使用 `\*`。 |
| +        | ==匹配前面的子表达式一次或多次==。要匹配 + 字符，请使用 `\+`。 |
| [ ]      | ==标记一个中括号表达式的开始和结束==。要匹配这些字符，请使用 `\[`和`\]`。 |
| { }      | ==标记限定符表达式的开始和结束==。要匹配这些字符，请使用 `\{`和`\}`。 |
| \|       | ==指明两项之间的一个选择==。要匹配 \|，请使用 `\|`。         |



### 4. 限定符

限定符用来指定正则表达式的**一个给定组件**(前面的一个组合)必须要出现多少次才能满足匹配。有 ***** 或 **+** 或 **?** 或 **{n}** 或 **{n,}** 或 **{n,m}** 共6种。

正则表达式的限定符有：

| 字符  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| *     | 匹配前面的子表达式==零次或多次==。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +     | 匹配前面的子表达式==一次或多次==。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?     | 匹配前面的子表达式==零次或一次==。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| {n}   | n 是一个非负整数。==匹配确定的 n 次==。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  | n 是一个非负整数。==至少匹配n 次==。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。==最少匹配 n 次且最多匹配 m 次==。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。**请注意在逗号和两个数之间不能有空格。** |

正则表达式匹配一个正整数，**[1-9]**设置第一个数字不是 0，**[0-9]\*** 表示任意多个数字

如果你想设置 0~99 的两位数，可以使用下面的表达式来至少指定一位但至多两位数字。

```tex
/[0-9]{1,2}/
```

上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。

改进下，匹配 1~99 的正整数表达式如下：

```tex
/[1-9][0-9]?/ 
   					 %% 或者
/[1-9][0-9]{0,1}/
```

- ### `?` 贪婪匹配和非贪婪匹配

**`*` 和`+`限定符==都是贪婪的==，因为它们会尽可能多的匹配文字**，只有在它们的后面加上一个` ?` 就可以实现非贪婪或最小匹配。

例如，您可能搜索 HTML 文档，以查找在 **h1** 标签内的内容:

```html
<title> abin 学习正则表达式 </title>
```

`<.*>`和`<.+>` 默认是贪婪匹配(最大匹配), 会匹配整个字符串

**贪婪：**下面的表达式匹配从开始小于符号 (<) 到关闭 h1 标记的大于符号 (>) 之间的所有内容。

![image-20220608140259260](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220608140259260.png)

**非贪婪：**如果只需要匹配开始和结束 title 标签，下面的非贪婪表达式只匹配 <title>。

![image-20220608140919683](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220608140919683.png)

结论:  ==当 **?** 紧跟在任何一个其他限定符 (***, +, ?, {n}, {n,}, {n,m}**) 后面时，匹配模式是非贪婪的，该表达式从"贪婪"表达式转换为"非贪婪"表达式或者最小匹配。==



### 5. 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

正则表达式的定位符有：

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入==字符串开始的位置==。如果设置了 RegExp 对象的 **Multiline** 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入==字符串结尾的位置==。如果设置了 RegExp 对象的 **Multiline** 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配==一个单词边界==，即字与空格间的位置。                   |
| \B   | ==非单词边界匹配==。                                         |

**注意**：==**不能将限定符与定位符一起使用**==。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 **^\*** 之类的表达式。

若要匹配一行文本开始处的文本，请在正则表达式的开始使用 **^** 字符。不要将 **^** 的这种用法与中括号表达式`[^ABC]`内的用法混淆。

若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 **$** 字符。

- **(使用 `^` 和 `$` 匹配字符串的开始和结束的时候需要考虑是否开启RegExp 对象的 Multiline 属性)**



若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：

```txt
^Chapter [1-9][0-9]{0,1}							// 开启了RegExp 对象的 Multiline 属性
```

![image-20220608145301564](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220608145301564.png)

下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：

```txt
Chapter [1-9][0-9]{0,1}$						// 开启了RegExp 对象的 Multiline 属性
```

![image-20220608145353514](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220608145353514.png)

真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它既出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。

```txt
^Chapter [1-9][0-9]{0,1}$					// 开启了RegExp 对象的 Multiline 属性
```

![image-20220608145444593](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220608145444593.png)

匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：

```txt
\bCha						
```

![image-20220608145719968](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220608145719968.png)

**\b** 字符的位置是非常重要的。**如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项**。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：

```txt
ter\b
```

![image-20220608145826340](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220608145826340.png)

下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：

```txt
\Bapt
```

![image-20220608145920095](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220608145920095.png)

字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。==对于 **\B** 非单词边界运算符，不可以匹配单词的开头或结尾==，如果是下面的表达式，就不匹配 Chapter 中的 Cha：

```txt
\BCha
```

![image-20220608145946772](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220608145946772.png)

### 6. 选择(或)匹配符

在匹配某个字符串的时候是有选择性, 既可以匹配这个, 又可以匹配那个. 这个时候需要用到 `|` 选择匹配符号, 类似于或or的关系

![image-20220609170741019](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220609170741019.png)

### 7. 分组与捕获

分组是用圆括号“()”括起来的正则表达式，匹配出的内容就表示一个分组;

- **`(exp)`** ：**匿名捕获分组，并==捕获==该分组捕获的文本**，分组的正则是exp，系统自动分配组号，相关的匹配会被缓存，可以通过分组号引用该分组；
- **`(?<name>exp)`** ：**命名捕获分组，并==捕获==该分组捕获的文本 **，分组的正则是exp系统为该分组分配分组号，相关的匹配会被缓存，可以通过**分组名或分组号**引用该分组；
- **`(?:exp)`** ：**不捕获分组，但==不捕获==该分组匹配到的文本**，该分组只在当前位置匹配文本，在该分组之后，无法引用该分组，因为该分组没有分组名，没有分组号，也不会占用分组编号；

捕获的定义: 使用小括号指定一个子表达式后，相关的匹配会被缓存，子表达式匹配的文本（即匹配的内容）可以在其他子表达式中重复使用。

捕获与非捕获的区别:    捕获组会缓存匹配的内容, 非捕获组不会缓存匹配的内容.



#### 捕获组编号规则

如果没有显式为捕获组命名，即没有使用命名捕获组，那么需要按数字顺序来访问所有捕获组。在只有普通捕获组的情况下，**捕获组的编号是按照==左括号“(”出现的顺序==，从左到右，从1开始进行编号的 。**

![image-20220609223622620](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220609223622620.png)

上面的正则表达式可以用来匹配格式为yyyy-MM-dd的日期，为了在下表中得以区分，月和日分别采用了\d{2}和\d\d这两种写法。
用以上正则表达式匹配字符串：2008-12-31，匹配结果为：

![image-20220609224133444](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220609224133444.png)



### 8.零宽断言

什么是断言:

​		广义上理解，断言(assertions)，从字面上理解就是，判定`是`，还是`否`。在**正则表达式的系统里，也就是`匹配`或者`不匹配`**。随便写一个正则表达式，都能产生`匹配`或者`不匹配`的结果，所以，可以这样说，所有的正则表达式都可以叫断言。

​		有时候，经常会看到看到这个概念，零宽断言(zero-width assertions)。普通的断言，比如`\d+`(匹配一个或者多个数字)，它所匹配的内容是由长度的；**而有些断言比如`^`和`$`(分别匹配行开头和结尾)==匹配的仅仅是一个位置，这样可以理解为它所匹配的内容长度为0==。所以，称这类断言为零宽断言(zero-width assertions)。**



#### 先行断言(lookahead)和后行断言(lookbehind)

正则表达式的先行断言和后行断言一共有 4 种形式：

- **(?=pattern)** 零宽正向先行断言(zero-width positive lookahead assertion)
- **(?!pattern)** 零宽负向先行断言(zero-width negative lookahead assertion)
- **(?<=pattern)** 零宽正向后行断言(zero-width positive lookbehind assertion)
- **(?<!pattern)** 零宽负向后行断言(zero-width negative lookbehind assertion)

这里面的 **pattern** 是一个正则表达式。这些断言都是**非捕获组**, 不会缓存匹配的内容

如同 **^** 代表开头，**$** 代表结尾，**\b** 代表单词边界一样，先行断言和后行断言也有类似的作用，它们只匹配某些位置，在匹配过程中，不占用字符，所以被称为**"零宽"**。所谓位置，是指字符串中(每行)第一个字符的左边、最后一个字符的右边以及相邻字符的中间（假设文字方向是头左尾右）。

| 符号            |        名字        |                代表意思                |
| --------------- | :----------------: | :------------------------------------: |
| **reg(?=exp)**  | 零宽度正向先行断言 |  reg匹配的内容**后面内容满足exp规则**  |
| **reg(?!exp)**  | 零宽度负向先行断言 | reg匹配的内容**后面内容不满足exp规则** |
| **(?<=exp)reg** | 零宽度正向后行断言 |  reg匹配的内容**前面内容满足exp规则**  |
| **(?<!exp)reg** | 零宽度负向后行断言 | reg匹配的内容**前面内容不满足exp规则** |



#### (?=pattern) 正向先行断言

代表字符串中的一个位置，**紧接该位置之后**的字符序列**能够匹配** pattern。

例如对 **"a regular expression"** 这个字符串，要想匹配 regular 中的 re，但不能匹配 expression 中的 re，可以用 **re(?=gular)**，该表达式限定了 re 右边的位置，这个位置之后是 gular，但并不消耗 gular 这些字符。

![image-20220610141407880](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610141407880.png)

#### (?!pattern) 负向先行断言

代表字符串中的一个位置，**紧接该位置之后**的字符序列**不能匹配** pattern。

例如对 **"regex represents regular expression"** 这个字符串，要想匹配除 regex 和 regular 之外的 re，可以用 **re(?!g)**，该表达式限定了 **re** 右边的位置，这个位置后面不是字符 **g**。负向和正向的区别，就在于该位置之后的字符能否匹配括号中的表达式。

![image-20220610141716772](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610141716772.png)

#### (?<=pattern) 正向后行断言

代表字符串中的一个位置，**紧接该位置之前**的字符序列**能够匹配** pattern。

例如对 **regex represents regular expression** 这个字符串，有 4 个单词，要想匹配单词内部的 re，但不匹配单词开头的 re，可以用 **(?<=\w)re**，单词内部的 re，在 re 前面应该是一个单词字符。

之所以叫后行断言，是因为正则表达式引擎在匹配字符串和表达式时，是从前向后逐个扫描字符串中的字符，并判断是否与表达式符合，当在表达式中遇到该断言时，正则表达式引擎需要往字符串前端检测已扫描过的字符，相对于扫描方向是向后的。

![image-20220610142047519](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610142047519.png)

#### (?<!pattern) 负向后行断言

代表字符串中的一个位置，**紧接该位置之前**的字符序列**不能匹配** pattern。

例如对 **"regex represents regular expression"** 这个字符串，要想匹配单词开头的 re，可以用 **(?<!\w)re**。单词开头的 **re**，在本例中，也就是指不在单词内部的 **re**，即 **re** 前面不是单词字符。当然也可以用 **\bre** 来匹配。

![image-20220610142129571](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610142129571.png)



对于这 4 个断言的理解，可以从两个方面入手：

- **1、关于先行(lookahead)和后行(lookbehind)：**正则表达式引擎在执行字符串和表达式匹配时，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。
- **2、关于正向(positive)和负向(negative)：**正向就表示匹配括号中的表达式，负向表示不匹配。

对这 4 个断言形式的记忆：

- **1、先行和后行：**后行断言 **(?<=pattern)、(?<!pattern)** 中，有个小于号，同时也是箭头，对于自左至右的文本方向，这个箭头是指向后的，这也比较符合我们的习惯。把小于号去掉，就是先行断言。
- **2、正向和负向：**不等于 **(!=)**、逻辑非 **(!)** 都是用 **!**号来表示，所以有 **!** 号的形式表示不匹配、负向；将 **!** 号换成 **=** 号，就表示匹配、正向。

注意: 大部分编程语言对先行断言都提供支持, 但是后行断言有些语言不支持



### 9. 反向引用

**反向引用的作用通常是用来查找或限定重复、查找或限定指定标识配对出现等等。对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中(捕获组)，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。==每个缓冲区都可以使用` \n` 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。==**

反向引用依赖于分组和捕获。可以使用非捕获元字符 **?:**、**?=** 或 **?!** 来重写捕获，忽略对相关匹配的保存。



对于普通捕获组和命名捕获组的引用，语法如下：

普通捕获组反向引用：`\k<number>`，通常简写为`\number`

命名捕获组反向引用：`\k<name>`或者`\k'name'`

普通捕获组反向引用中number是十进制的数字，即捕获组的编号；命名捕获组反向引用中的name为命名捕获组的组名。



#### 反向引用匹配原理

**捕获组(Expression)在匹配成功时，会将子表达式匹配到的内容，保存到内存中一个以数字编号的组里**，可以简单的认为是对一个局部变量进行了赋值，这时就可以通过反向引用方式，引用这个局部变量的值。一个捕获组(Expression)在匹配成功之前，它的内容可以是不确定的，一旦匹配成功，它的内容就确定了，反向引用的内容也就是确定的了。

**反向引用必然要与捕获组一同使用的**，如果没有捕获组，而使用了反向引用的语法，不同语言的处理方式不一致，有的语言会抛异常，有的语言会当作普通的转义处理。



#### 相关案例

不考虑闰年等的情况下，对年月日进行简单匹配，可以用**`\d{4}-\d{1,2}-\d{1,2}`**。结果如下图所示。

![image-20220610145958024](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610145958024.png)

对于类似"2022-10-01"的字符串能够成功匹配。如果字符串中的日期分隔符不只有"-"，还可能有"/"的话，就需要改变一下表达式。

![image-20220610150504074](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610150504074.png)

将正则表达式改为**`\d{4}[-/]\d{1,2}[-/]\d{1,2}`**，便可以匹配两种分隔符了。但这种表达式也存在一个问题，会把类似"2018-04/27"**分隔符不一致**的也匹配成功。

![image-20220610151046908](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610151046908.png)

现在我们需要根据前一个日期分隔符，来确定下一个日期分隔符的样式，这时候就需要**反向引用**出场了。语法为**` \groupNumber `**.

![image-20220610151745660](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610151745660.png)

正则表达式**`\d{4}([-/])\d{1,2}\1\d{1,2}`**中的 **`\1`** 表示引用第一个捕获组的内容，当第一个分隔符为"-“时，`\1`的内容就是”-"；当第一个分隔符为"/"时，`\1`的内容就是"/"。

除了使用数字捕获组，同样可以使用命名捕获组来反向引用。

语法为:  **`\k<groupName>`**,  例如本例子中 **`\d{4}(?<separator>[-/])\d{1,2}\k<separator>\d{1,2}`**可以达到同样的效果。

![image-20220610152420155](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610152420155.png)

注意： **大部分编程语言对数字捕获组都提供了支持，但是命名捕获组有些语言不支持**

[反向引用详解](https://blog.csdn.net/lxcnn/article/details/4476746?spm=1001.2014.3001.5502)



## 三. 正则表达式修饰符(标记)

标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。

**标记不写在正则表达式里，标记位于表达式之外**，格式如下：(不同编程语言格式不同)

```txt
/pattern/flags
```

| 修饰符 | 含义                                   | 描述                                                         |
| :----- | :------------------------------------- | :----------------------------------------------------------- |
| i      | ignore - 不区分大小写                  | 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 |
| g      | global - 全局匹配                      | 查找所有的匹配项。否则只会返回匹配到的第一个                 |
| m      | multi line - 多行匹配                  | 使边界字符 **^** 和 **$** 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 |
| s      | 特殊字符圆点 **.** 中包含换行符 **\n** | 默认情况下的圆点 **.** 是匹配除换行符 **\n** 之外的任何字符，加上 **s** 修饰符之后, **.** 中包含换行符 \n。 |



## 四. 正则表达式运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：

| 运算符                      | 描述                                                         |
| :-------------------------- | :----------------------------------------------------------- |
| \                           | 转义符                                                       |
| (), (?:), (?=), []          | 圆括号和方括号                                               |
| *, +, ?, {n}, {n,}, {n,m}   | 限定符                                                       |
| ^, $, \任何元字符、任何字符 | 定位点和序列（即：位置和顺序）                               |
| \|                          | 替换，"或"操作 字符具有高于替换运算符的优先级，使得"m\|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m\|f)ood"。 |



## 五. 元字符清单

下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：

| 字符         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| \            | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。 |
| ^            | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。 |
| $            | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。 |
| *            | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +            | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?            | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。 |
| {n}          | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}         | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m}        | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |
| ?            | **当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的**。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。 |
| .            | 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"**(.\|\n)**"的模式。 |
| (pattern)    | 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。 |
| (?:pattern)  | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (\|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\|ies) 就是一个比 'industry\|industries' 更简略的表达式。 |
| (?=pattern)  | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95\|98\|NT\|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!pattern)  | 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95\|98\|NT\|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?<=pattern) | 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"`(?<=95|98|NT|2000)Windows`"能匹配"`2000Windows`"中的"`Windows`"，但不能匹配"`3.1Windows`"中的"`Windows`"。 |
| (?<!pattern) | 反向否定预查，与正向否定预查类似，只是方向相反。例如"`(?<!95|98|NT|2000)Windows`"能匹配"`3.1Windows`"中的"`Windows`"，但不能匹配"`2000Windows`"中的"`Windows`"。 |
| x\|y         | 匹配 x 或 y。例如，'z\|food' 能匹配 "z" 或 "food"。'(z\|f)ood' 则匹配 "zood" 或 "food"。 |
| [xyz]        | 字符集合。匹配所包含的任意一个字符。例如， `[abc]`可以匹配 "plain" 中的 'a'。 |
| [^xyz]       | 负值字符集合。匹配未包含的任意字符。例如， `[^abc]` 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。 |
| [a-z]        | 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。 |
| [^a-z]       | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，`[^a-z]`可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 |
| \b           | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
| \B           | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
| \cx          | 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \d           | 匹配一个数字字符。等价于 [0-9]。                             |
| \D           | 匹配一个非数字字符。等价于 `[^0-9]`。                        |
| \f           | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n           | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r           | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| \s           | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
| \S           | 匹配任何非空白字符。等价于 `[^ \f\n\r\t\v]`。                |
| \t           | 匹配一个制表符。等价于 \x09 和 \cI。                         |
| \v           | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |
| \w           | 匹配字母、数字、下划线。等价于`[A-Za-z0-9_]`。               |
| \W           | 匹配非字母、数字、下划线。等价于 `[^A-Za-z0-9_]`。           |
| \xn          | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。 |
| \num         | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。 |
| \n           | 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |
| \nm          | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 |
| \nml         | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |
| \un          | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 |

案例: 匹配邮箱

```tex
\b[\w.%+-]+@[\w.-]+\.[a-zA-Z]{2,6}\b
```

![regexp-metachar-2020-11-23](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/regexp-metachar-2020-11-23.png)

![image-20220610170756061](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610170756061.png)



## 六. 相关工具：

- #### [可视化正则 JavaScript Regular Expression Visualizer](https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24)

用于匹配日期的正则: **`(^[1|2]?\d{1,3})([-/])(([1][012]?|0?[1-9])\2(3[0,1]|[12]\d?|0?[1-9]))(?!\d)`**

![image-20220610155106011](https://my-pic-bed.oss-cn-chengdu.aliyuncs.com/typora_picture/image-20220610155106011.png)

-  [在线测试工具](https://regex101.com/)
-  [常用正则表达式, 菜鸟工具](https://c.runoob.com/front-end/854/)
-  [正则可视化](https://regexper.com/)
-  [Regulex可视化](https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24)

## 七. 参考博客：

- [正则表达式](https://www.jianshu.com/p/323c6f3afa62)

-  #### [正则表达式之基本原理 ](https://www.cnblogs.com/longhuihu/p/4128203.html)

-  #### [正则表达式引擎执行原理](https://zhuanlan.zhihu.com/p/107836267)

- #### [浅谈正则表达式原理](https://zhuanlan.zhihu.com/p/73640948)



